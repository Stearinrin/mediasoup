// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_
#define FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "sctpParameters_generated.h"
#include "transport_generated.h"

namespace FBS {
namespace WebRtcTransport {

struct WebRtcTransportListenIndividual;
struct WebRtcTransportListenIndividualBuilder;

struct WebRtcTransportListenServer;
struct WebRtcTransportListenServerBuilder;

struct WebRtcTransportOptions;
struct WebRtcTransportOptionsBuilder;

inline const flatbuffers::TypeTable *WebRtcTransportListenIndividualTypeTable();

inline const flatbuffers::TypeTable *WebRtcTransportListenServerTypeTable();

inline const flatbuffers::TypeTable *WebRtcTransportOptionsTypeTable();

enum class WebRtcTransportListen : uint8_t {
  NONE = 0,
  WebRtcTransportListenIndividual = 1,
  WebRtcTransportListenServer = 2,
  MIN = NONE,
  MAX = WebRtcTransportListenServer
};

inline const WebRtcTransportListen (&EnumValuesWebRtcTransportListen())[3] {
  static const WebRtcTransportListen values[] = {
    WebRtcTransportListen::NONE,
    WebRtcTransportListen::WebRtcTransportListenIndividual,
    WebRtcTransportListen::WebRtcTransportListenServer
  };
  return values;
}

inline const char * const *EnumNamesWebRtcTransportListen() {
  static const char * const names[4] = {
    "NONE",
    "WebRtcTransportListenIndividual",
    "WebRtcTransportListenServer",
    nullptr
  };
  return names;
}

inline const char *EnumNameWebRtcTransportListen(WebRtcTransportListen e) {
  if (flatbuffers::IsOutRange(e, WebRtcTransportListen::NONE, WebRtcTransportListen::WebRtcTransportListenServer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWebRtcTransportListen()[index];
}

template<typename T> struct WebRtcTransportListenTraits {
  static const WebRtcTransportListen enum_value = WebRtcTransportListen::NONE;
};

template<> struct WebRtcTransportListenTraits<FBS::WebRtcTransport::WebRtcTransportListenIndividual> {
  static const WebRtcTransportListen enum_value = WebRtcTransportListen::WebRtcTransportListenIndividual;
};

template<> struct WebRtcTransportListenTraits<FBS::WebRtcTransport::WebRtcTransportListenServer> {
  static const WebRtcTransportListen enum_value = WebRtcTransportListen::WebRtcTransportListenServer;
};

bool VerifyWebRtcTransportListen(flatbuffers::Verifier &verifier, const void *obj, WebRtcTransportListen type);
bool VerifyWebRtcTransportListenVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<WebRtcTransportListen> *types);

struct WebRtcTransportListenIndividual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcTransportListenIndividualBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcTransportListenIndividualTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LISTENIPS = 4,
    VT_PORT = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::TransportListenIp>> *listenIps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::TransportListenIp>> *>(VT_LISTENIPS);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LISTENIPS) &&
           verifier.VerifyVector(listenIps()) &&
           verifier.VerifyVectorOfTables(listenIps()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct WebRtcTransportListenIndividualBuilder {
  typedef WebRtcTransportListenIndividual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_listenIps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::TransportListenIp>>> listenIps) {
    fbb_.AddOffset(WebRtcTransportListenIndividual::VT_LISTENIPS, listenIps);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(WebRtcTransportListenIndividual::VT_PORT, port, 0);
  }
  explicit WebRtcTransportListenIndividualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcTransportListenIndividual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcTransportListenIndividual>(end);
    fbb_.Required(o, WebRtcTransportListenIndividual::VT_LISTENIPS);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcTransportListenIndividual> CreateWebRtcTransportListenIndividual(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::TransportListenIp>>> listenIps = 0,
    uint16_t port = 0) {
  WebRtcTransportListenIndividualBuilder builder_(_fbb);
  builder_.add_listenIps(listenIps);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebRtcTransportListenIndividual> CreateWebRtcTransportListenIndividualDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::Transport::TransportListenIp>> *listenIps = nullptr,
    uint16_t port = 0) {
  auto listenIps__ = listenIps ? _fbb.CreateVector<flatbuffers::Offset<FBS::Transport::TransportListenIp>>(*listenIps) : 0;
  return FBS::WebRtcTransport::CreateWebRtcTransportListenIndividual(
      _fbb,
      listenIps__,
      port);
}

struct WebRtcTransportListenServer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcTransportListenServerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcTransportListenServerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEBRTCSERVERID = 4
  };
  const flatbuffers::String *webRtcServerId() const {
    return GetPointer<const flatbuffers::String *>(VT_WEBRTCSERVERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WEBRTCSERVERID) &&
           verifier.VerifyString(webRtcServerId()) &&
           verifier.EndTable();
  }
};

struct WebRtcTransportListenServerBuilder {
  typedef WebRtcTransportListenServer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_webRtcServerId(flatbuffers::Offset<flatbuffers::String> webRtcServerId) {
    fbb_.AddOffset(WebRtcTransportListenServer::VT_WEBRTCSERVERID, webRtcServerId);
  }
  explicit WebRtcTransportListenServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcTransportListenServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcTransportListenServer>(end);
    fbb_.Required(o, WebRtcTransportListenServer::VT_WEBRTCSERVERID);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcTransportListenServer> CreateWebRtcTransportListenServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> webRtcServerId = 0) {
  WebRtcTransportListenServerBuilder builder_(_fbb);
  builder_.add_webRtcServerId(webRtcServerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebRtcTransportListenServer> CreateWebRtcTransportListenServerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *webRtcServerId = nullptr) {
  auto webRtcServerId__ = webRtcServerId ? _fbb.CreateString(webRtcServerId) : 0;
  return FBS::WebRtcTransport::CreateWebRtcTransportListenServer(
      _fbb,
      webRtcServerId__);
}

struct WebRtcTransportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcTransportOptionsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcTransportOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_LISTEN_TYPE = 6,
    VT_LISTEN = 8,
    VT_ENABLEUDP = 10,
    VT_ENABLETCP = 12,
    VT_PREFERUDP = 14,
    VT_PREFERTCP = 16
  };
  const FBS::Transport::BaseTransportOptions *base() const {
    return GetPointer<const FBS::Transport::BaseTransportOptions *>(VT_BASE);
  }
  FBS::WebRtcTransport::WebRtcTransportListen listen_type() const {
    return static_cast<FBS::WebRtcTransport::WebRtcTransportListen>(GetField<uint8_t>(VT_LISTEN_TYPE, 0));
  }
  const void *listen() const {
    return GetPointer<const void *>(VT_LISTEN);
  }
  template<typename T> const T *listen_as() const;
  const FBS::WebRtcTransport::WebRtcTransportListenIndividual *listen_as_WebRtcTransportListenIndividual() const {
    return listen_type() == FBS::WebRtcTransport::WebRtcTransportListen::WebRtcTransportListenIndividual ? static_cast<const FBS::WebRtcTransport::WebRtcTransportListenIndividual *>(listen()) : nullptr;
  }
  const FBS::WebRtcTransport::WebRtcTransportListenServer *listen_as_WebRtcTransportListenServer() const {
    return listen_type() == FBS::WebRtcTransport::WebRtcTransportListen::WebRtcTransportListenServer ? static_cast<const FBS::WebRtcTransport::WebRtcTransportListenServer *>(listen()) : nullptr;
  }
  bool enableUdp() const {
    return GetField<uint8_t>(VT_ENABLEUDP, 1) != 0;
  }
  bool enableTcp() const {
    return GetField<uint8_t>(VT_ENABLETCP, 0) != 0;
  }
  bool preferUdp() const {
    return GetField<uint8_t>(VT_PREFERUDP, 0) != 0;
  }
  bool preferTcp() const {
    return GetField<uint8_t>(VT_PREFERTCP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint8_t>(verifier, VT_LISTEN_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_LISTEN) &&
           VerifyWebRtcTransportListen(verifier, listen(), listen_type()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLEUDP, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENABLETCP, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREFERUDP, 1) &&
           VerifyField<uint8_t>(verifier, VT_PREFERTCP, 1) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::WebRtcTransport::WebRtcTransportListenIndividual *WebRtcTransportOptions::listen_as<FBS::WebRtcTransport::WebRtcTransportListenIndividual>() const {
  return listen_as_WebRtcTransportListenIndividual();
}

template<> inline const FBS::WebRtcTransport::WebRtcTransportListenServer *WebRtcTransportOptions::listen_as<FBS::WebRtcTransport::WebRtcTransportListenServer>() const {
  return listen_as_WebRtcTransportListenServer();
}

struct WebRtcTransportOptionsBuilder {
  typedef WebRtcTransportOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<FBS::Transport::BaseTransportOptions> base) {
    fbb_.AddOffset(WebRtcTransportOptions::VT_BASE, base);
  }
  void add_listen_type(FBS::WebRtcTransport::WebRtcTransportListen listen_type) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_LISTEN_TYPE, static_cast<uint8_t>(listen_type), 0);
  }
  void add_listen(flatbuffers::Offset<void> listen) {
    fbb_.AddOffset(WebRtcTransportOptions::VT_LISTEN, listen);
  }
  void add_enableUdp(bool enableUdp) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_ENABLEUDP, static_cast<uint8_t>(enableUdp), 1);
  }
  void add_enableTcp(bool enableTcp) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_ENABLETCP, static_cast<uint8_t>(enableTcp), 0);
  }
  void add_preferUdp(bool preferUdp) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_PREFERUDP, static_cast<uint8_t>(preferUdp), 0);
  }
  void add_preferTcp(bool preferTcp) {
    fbb_.AddElement<uint8_t>(WebRtcTransportOptions::VT_PREFERTCP, static_cast<uint8_t>(preferTcp), 0);
  }
  explicit WebRtcTransportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcTransportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcTransportOptions>(end);
    fbb_.Required(o, WebRtcTransportOptions::VT_LISTEN);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcTransportOptions> CreateWebRtcTransportOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::BaseTransportOptions> base = 0,
    FBS::WebRtcTransport::WebRtcTransportListen listen_type = FBS::WebRtcTransport::WebRtcTransportListen::NONE,
    flatbuffers::Offset<void> listen = 0,
    bool enableUdp = true,
    bool enableTcp = false,
    bool preferUdp = false,
    bool preferTcp = false) {
  WebRtcTransportOptionsBuilder builder_(_fbb);
  builder_.add_listen(listen);
  builder_.add_base(base);
  builder_.add_preferTcp(preferTcp);
  builder_.add_preferUdp(preferUdp);
  builder_.add_enableTcp(enableTcp);
  builder_.add_enableUdp(enableUdp);
  builder_.add_listen_type(listen_type);
  return builder_.Finish();
}

inline bool VerifyWebRtcTransportListen(flatbuffers::Verifier &verifier, const void *obj, WebRtcTransportListen type) {
  switch (type) {
    case WebRtcTransportListen::NONE: {
      return true;
    }
    case WebRtcTransportListen::WebRtcTransportListenIndividual: {
      auto ptr = reinterpret_cast<const FBS::WebRtcTransport::WebRtcTransportListenIndividual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case WebRtcTransportListen::WebRtcTransportListenServer: {
      auto ptr = reinterpret_cast<const FBS::WebRtcTransport::WebRtcTransportListenServer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyWebRtcTransportListenVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<WebRtcTransportListen> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyWebRtcTransportListen(
        verifier,  values->Get(i), types->GetEnum<WebRtcTransportListen>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *WebRtcTransportListenTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::WebRtcTransport::WebRtcTransportListenIndividualTypeTable,
    FBS::WebRtcTransport::WebRtcTransportListenServerTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "WebRtcTransportListenIndividual",
    "WebRtcTransportListenServer"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcTransportListenIndividualTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TransportListenIpTypeTable
  };
  static const char * const names[] = {
    "listenIps",
    "port"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcTransportListenServerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "webRtcServerId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcTransportOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::BaseTransportOptionsTypeTable,
    FBS::WebRtcTransport::WebRtcTransportListenTypeTable
  };
  static const char * const names[] = {
    "base",
    "listen_type",
    "listen",
    "enableUdp",
    "enableTcp",
    "preferUdp",
    "preferTcp"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace WebRtcTransport
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_WEBRTCTRANSPORT_FBS_WEBRTCTRANSPORT_H_
