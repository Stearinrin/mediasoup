// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORKER_FBS_WORKER_H_
#define FLATBUFFERS_GENERATED_WORKER_FBS_WORKER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace FBS {
namespace Worker {

struct ChannelMessageHandlers;
struct ChannelMessageHandlersBuilder;

struct WorkerDump;
struct WorkerDumpBuilder;

struct ResourceUsage;
struct ResourceUsageBuilder;

struct UpdateableSettings;
struct UpdateableSettingsBuilder;

struct WebRtcServerListenInfo;
struct WebRtcServerListenInfoBuilder;

struct CreateWebRtcServerRequest;
struct CreateWebRtcServerRequestBuilder;

inline const flatbuffers::TypeTable *ChannelMessageHandlersTypeTable();

inline const flatbuffers::TypeTable *WorkerDumpTypeTable();

inline const flatbuffers::TypeTable *ResourceUsageTypeTable();

inline const flatbuffers::TypeTable *UpdateableSettingsTypeTable();

inline const flatbuffers::TypeTable *WebRtcServerListenInfoTypeTable();

inline const flatbuffers::TypeTable *CreateWebRtcServerRequestTypeTable();

enum class TransportProtocol : uint8_t {
  UDP = 1,
  TCP = 2,
  MIN = UDP,
  MAX = TCP
};

inline const TransportProtocol (&EnumValuesTransportProtocol())[2] {
  static const TransportProtocol values[] = {
    TransportProtocol::UDP,
    TransportProtocol::TCP
  };
  return values;
}

inline const char * const *EnumNamesTransportProtocol() {
  static const char * const names[3] = {
    "UDP",
    "TCP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTransportProtocol(TransportProtocol e) {
  if (flatbuffers::IsOutRange(e, TransportProtocol::UDP, TransportProtocol::TCP)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TransportProtocol::UDP);
  return EnumNamesTransportProtocol()[index];
}

struct ChannelMessageHandlers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChannelMessageHandlersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChannelMessageHandlersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELREQUESTHANDLERS = 4,
    VT_PAYLOADCHANNELREQUESTHANDLERS = 6,
    VT_PAYLOADCHANNELNOTIFICATIONHANDLERS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *channelRequestHandlers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CHANNELREQUESTHANDLERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *payloadchannelRequestHandlers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PAYLOADCHANNELREQUESTHANDLERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *payloadchannelNotificationHandlers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PAYLOADCHANNELNOTIFICATIONHANDLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNELREQUESTHANDLERS) &&
           verifier.VerifyVector(channelRequestHandlers()) &&
           verifier.VerifyVectorOfStrings(channelRequestHandlers()) &&
           VerifyOffset(verifier, VT_PAYLOADCHANNELREQUESTHANDLERS) &&
           verifier.VerifyVector(payloadchannelRequestHandlers()) &&
           verifier.VerifyVectorOfStrings(payloadchannelRequestHandlers()) &&
           VerifyOffset(verifier, VT_PAYLOADCHANNELNOTIFICATIONHANDLERS) &&
           verifier.VerifyVector(payloadchannelNotificationHandlers()) &&
           verifier.VerifyVectorOfStrings(payloadchannelNotificationHandlers()) &&
           verifier.EndTable();
  }
};

struct ChannelMessageHandlersBuilder {
  typedef ChannelMessageHandlers Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelRequestHandlers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> channelRequestHandlers) {
    fbb_.AddOffset(ChannelMessageHandlers::VT_CHANNELREQUESTHANDLERS, channelRequestHandlers);
  }
  void add_payloadchannelRequestHandlers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> payloadchannelRequestHandlers) {
    fbb_.AddOffset(ChannelMessageHandlers::VT_PAYLOADCHANNELREQUESTHANDLERS, payloadchannelRequestHandlers);
  }
  void add_payloadchannelNotificationHandlers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> payloadchannelNotificationHandlers) {
    fbb_.AddOffset(ChannelMessageHandlers::VT_PAYLOADCHANNELNOTIFICATIONHANDLERS, payloadchannelNotificationHandlers);
  }
  explicit ChannelMessageHandlersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChannelMessageHandlers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChannelMessageHandlers>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChannelMessageHandlers> CreateChannelMessageHandlers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> channelRequestHandlers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> payloadchannelRequestHandlers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> payloadchannelNotificationHandlers = 0) {
  ChannelMessageHandlersBuilder builder_(_fbb);
  builder_.add_payloadchannelNotificationHandlers(payloadchannelNotificationHandlers);
  builder_.add_payloadchannelRequestHandlers(payloadchannelRequestHandlers);
  builder_.add_channelRequestHandlers(channelRequestHandlers);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChannelMessageHandlers> CreateChannelMessageHandlersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *channelRequestHandlers = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *payloadchannelRequestHandlers = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *payloadchannelNotificationHandlers = nullptr) {
  auto channelRequestHandlers__ = channelRequestHandlers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*channelRequestHandlers) : 0;
  auto payloadchannelRequestHandlers__ = payloadchannelRequestHandlers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*payloadchannelRequestHandlers) : 0;
  auto payloadchannelNotificationHandlers__ = payloadchannelNotificationHandlers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*payloadchannelNotificationHandlers) : 0;
  return FBS::Worker::CreateChannelMessageHandlers(
      _fbb,
      channelRequestHandlers__,
      payloadchannelRequestHandlers__,
      payloadchannelNotificationHandlers__);
}

struct WorkerDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorkerDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WorkerDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PID = 4,
    VT_WEBRTCSERVERIDS = 6,
    VT_ROUTERIDS = 8,
    VT_CHANNELMESSAGEHANDLERS = 10
  };
  uint64_t pid() const {
    return GetField<uint64_t>(VT_PID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *webrtcServerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_WEBRTCSERVERIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *routerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ROUTERIDS);
  }
  const FBS::Worker::ChannelMessageHandlers *channelMessageHandlers() const {
    return GetPointer<const FBS::Worker::ChannelMessageHandlers *>(VT_CHANNELMESSAGEHANDLERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PID, 8) &&
           VerifyOffset(verifier, VT_WEBRTCSERVERIDS) &&
           verifier.VerifyVector(webrtcServerIds()) &&
           verifier.VerifyVectorOfStrings(webrtcServerIds()) &&
           VerifyOffset(verifier, VT_ROUTERIDS) &&
           verifier.VerifyVector(routerIds()) &&
           verifier.VerifyVectorOfStrings(routerIds()) &&
           VerifyOffset(verifier, VT_CHANNELMESSAGEHANDLERS) &&
           verifier.VerifyTable(channelMessageHandlers()) &&
           verifier.EndTable();
  }
};

struct WorkerDumpBuilder {
  typedef WorkerDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(uint64_t pid) {
    fbb_.AddElement<uint64_t>(WorkerDump::VT_PID, pid, 0);
  }
  void add_webrtcServerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> webrtcServerIds) {
    fbb_.AddOffset(WorkerDump::VT_WEBRTCSERVERIDS, webrtcServerIds);
  }
  void add_routerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> routerIds) {
    fbb_.AddOffset(WorkerDump::VT_ROUTERIDS, routerIds);
  }
  void add_channelMessageHandlers(flatbuffers::Offset<FBS::Worker::ChannelMessageHandlers> channelMessageHandlers) {
    fbb_.AddOffset(WorkerDump::VT_CHANNELMESSAGEHANDLERS, channelMessageHandlers);
  }
  explicit WorkerDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WorkerDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WorkerDump>(end);
    return o;
  }
};

inline flatbuffers::Offset<WorkerDump> CreateWorkerDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> webrtcServerIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> routerIds = 0,
    flatbuffers::Offset<FBS::Worker::ChannelMessageHandlers> channelMessageHandlers = 0) {
  WorkerDumpBuilder builder_(_fbb);
  builder_.add_pid(pid);
  builder_.add_channelMessageHandlers(channelMessageHandlers);
  builder_.add_routerIds(routerIds);
  builder_.add_webrtcServerIds(webrtcServerIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<WorkerDump> CreateWorkerDumpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t pid = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *webrtcServerIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *routerIds = nullptr,
    flatbuffers::Offset<FBS::Worker::ChannelMessageHandlers> channelMessageHandlers = 0) {
  auto webrtcServerIds__ = webrtcServerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*webrtcServerIds) : 0;
  auto routerIds__ = routerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*routerIds) : 0;
  return FBS::Worker::CreateWorkerDump(
      _fbb,
      pid,
      webrtcServerIds__,
      routerIds__,
      channelMessageHandlers);
}

struct ResourceUsage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourceUsageBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResourceUsageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RUUTIME = 4,
    VT_RUSTIME = 6,
    VT_RUMAXRSS = 8,
    VT_RUIXRSS = 10,
    VT_RUIDRSS = 12,
    VT_RUISRSS = 14,
    VT_RUMINFLT = 16,
    VT_RUMAJFLT = 18,
    VT_RUNSWAP = 20,
    VT_RUINBLOCK = 22,
    VT_RUOUBLOCK = 24,
    VT_RUMSGSND = 26,
    VT_RUMSGRCV = 28,
    VT_RUNSIGNALS = 30,
    VT_RUNVCSW = 32,
    VT_RUNIVCSW = 34
  };
  uint64_t ruUtime() const {
    return GetField<uint64_t>(VT_RUUTIME, 0);
  }
  uint64_t ruStime() const {
    return GetField<uint64_t>(VT_RUSTIME, 0);
  }
  uint64_t ruMaxrss() const {
    return GetField<uint64_t>(VT_RUMAXRSS, 0);
  }
  uint64_t ruIxrss() const {
    return GetField<uint64_t>(VT_RUIXRSS, 0);
  }
  uint64_t ruIdrss() const {
    return GetField<uint64_t>(VT_RUIDRSS, 0);
  }
  uint64_t ruIsrss() const {
    return GetField<uint64_t>(VT_RUISRSS, 0);
  }
  uint64_t ruMinflt() const {
    return GetField<uint64_t>(VT_RUMINFLT, 0);
  }
  uint64_t ruMajflt() const {
    return GetField<uint64_t>(VT_RUMAJFLT, 0);
  }
  uint64_t ruNswap() const {
    return GetField<uint64_t>(VT_RUNSWAP, 0);
  }
  uint64_t ruInblock() const {
    return GetField<uint64_t>(VT_RUINBLOCK, 0);
  }
  uint64_t ruOublock() const {
    return GetField<uint64_t>(VT_RUOUBLOCK, 0);
  }
  uint64_t ruMsgsnd() const {
    return GetField<uint64_t>(VT_RUMSGSND, 0);
  }
  uint64_t ruMsgrcv() const {
    return GetField<uint64_t>(VT_RUMSGRCV, 0);
  }
  uint64_t ruNsignals() const {
    return GetField<uint64_t>(VT_RUNSIGNALS, 0);
  }
  uint64_t ruNvcsw() const {
    return GetField<uint64_t>(VT_RUNVCSW, 0);
  }
  uint64_t ruNivcsw() const {
    return GetField<uint64_t>(VT_RUNIVCSW, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RUUTIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUSTIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUMAXRSS, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUIXRSS, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUIDRSS, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUISRSS, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUMINFLT, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUMAJFLT, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUNSWAP, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUINBLOCK, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUOUBLOCK, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUMSGSND, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUMSGRCV, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUNSIGNALS, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUNVCSW, 8) &&
           VerifyField<uint64_t>(verifier, VT_RUNIVCSW, 8) &&
           verifier.EndTable();
  }
};

struct ResourceUsageBuilder {
  typedef ResourceUsage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ruUtime(uint64_t ruUtime) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUUTIME, ruUtime, 0);
  }
  void add_ruStime(uint64_t ruStime) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUSTIME, ruStime, 0);
  }
  void add_ruMaxrss(uint64_t ruMaxrss) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUMAXRSS, ruMaxrss, 0);
  }
  void add_ruIxrss(uint64_t ruIxrss) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUIXRSS, ruIxrss, 0);
  }
  void add_ruIdrss(uint64_t ruIdrss) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUIDRSS, ruIdrss, 0);
  }
  void add_ruIsrss(uint64_t ruIsrss) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUISRSS, ruIsrss, 0);
  }
  void add_ruMinflt(uint64_t ruMinflt) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUMINFLT, ruMinflt, 0);
  }
  void add_ruMajflt(uint64_t ruMajflt) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUMAJFLT, ruMajflt, 0);
  }
  void add_ruNswap(uint64_t ruNswap) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUNSWAP, ruNswap, 0);
  }
  void add_ruInblock(uint64_t ruInblock) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUINBLOCK, ruInblock, 0);
  }
  void add_ruOublock(uint64_t ruOublock) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUOUBLOCK, ruOublock, 0);
  }
  void add_ruMsgsnd(uint64_t ruMsgsnd) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUMSGSND, ruMsgsnd, 0);
  }
  void add_ruMsgrcv(uint64_t ruMsgrcv) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUMSGRCV, ruMsgrcv, 0);
  }
  void add_ruNsignals(uint64_t ruNsignals) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUNSIGNALS, ruNsignals, 0);
  }
  void add_ruNvcsw(uint64_t ruNvcsw) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUNVCSW, ruNvcsw, 0);
  }
  void add_ruNivcsw(uint64_t ruNivcsw) {
    fbb_.AddElement<uint64_t>(ResourceUsage::VT_RUNIVCSW, ruNivcsw, 0);
  }
  explicit ResourceUsageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResourceUsage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourceUsage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourceUsage> CreateResourceUsage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ruUtime = 0,
    uint64_t ruStime = 0,
    uint64_t ruMaxrss = 0,
    uint64_t ruIxrss = 0,
    uint64_t ruIdrss = 0,
    uint64_t ruIsrss = 0,
    uint64_t ruMinflt = 0,
    uint64_t ruMajflt = 0,
    uint64_t ruNswap = 0,
    uint64_t ruInblock = 0,
    uint64_t ruOublock = 0,
    uint64_t ruMsgsnd = 0,
    uint64_t ruMsgrcv = 0,
    uint64_t ruNsignals = 0,
    uint64_t ruNvcsw = 0,
    uint64_t ruNivcsw = 0) {
  ResourceUsageBuilder builder_(_fbb);
  builder_.add_ruNivcsw(ruNivcsw);
  builder_.add_ruNvcsw(ruNvcsw);
  builder_.add_ruNsignals(ruNsignals);
  builder_.add_ruMsgrcv(ruMsgrcv);
  builder_.add_ruMsgsnd(ruMsgsnd);
  builder_.add_ruOublock(ruOublock);
  builder_.add_ruInblock(ruInblock);
  builder_.add_ruNswap(ruNswap);
  builder_.add_ruMajflt(ruMajflt);
  builder_.add_ruMinflt(ruMinflt);
  builder_.add_ruIsrss(ruIsrss);
  builder_.add_ruIdrss(ruIdrss);
  builder_.add_ruIxrss(ruIxrss);
  builder_.add_ruMaxrss(ruMaxrss);
  builder_.add_ruStime(ruStime);
  builder_.add_ruUtime(ruUtime);
  return builder_.Finish();
}

struct UpdateableSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpdateableSettingsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UpdateableSettingsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGLEVEL = 4,
    VT_LOGTAGS = 6
  };
  const flatbuffers::String *logLevel() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGLEVEL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *logTags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOGTAGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOGLEVEL) &&
           verifier.VerifyString(logLevel()) &&
           VerifyOffset(verifier, VT_LOGTAGS) &&
           verifier.VerifyVector(logTags()) &&
           verifier.VerifyVectorOfStrings(logTags()) &&
           verifier.EndTable();
  }
};

struct UpdateableSettingsBuilder {
  typedef UpdateableSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logLevel(flatbuffers::Offset<flatbuffers::String> logLevel) {
    fbb_.AddOffset(UpdateableSettings::VT_LOGLEVEL, logLevel);
  }
  void add_logTags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logTags) {
    fbb_.AddOffset(UpdateableSettings::VT_LOGTAGS, logTags);
  }
  explicit UpdateableSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UpdateableSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateableSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateableSettings> CreateUpdateableSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logLevel = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logTags = 0) {
  UpdateableSettingsBuilder builder_(_fbb);
  builder_.add_logTags(logTags);
  builder_.add_logLevel(logLevel);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdateableSettings> CreateUpdateableSettingsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logLevel = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *logTags = nullptr) {
  auto logLevel__ = logLevel ? _fbb.CreateString(logLevel) : 0;
  auto logTags__ = logTags ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*logTags) : 0;
  return FBS::Worker::CreateUpdateableSettings(
      _fbb,
      logLevel__,
      logTags__);
}

struct WebRtcServerListenInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcServerListenInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcServerListenInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL = 4,
    VT_IP = 6,
    VT_ANNOUNCEDIP = 8,
    VT_PORT = 10
  };
  FBS::Worker::TransportProtocol protocol() const {
    return static_cast<FBS::Worker::TransportProtocol>(GetField<uint8_t>(VT_PROTOCOL, 1));
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  const flatbuffers::String *announcedIp() const {
    return GetPointer<const flatbuffers::String *>(VT_ANNOUNCEDIP);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROTOCOL, 1) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyOffset(verifier, VT_ANNOUNCEDIP) &&
           verifier.VerifyString(announcedIp()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct WebRtcServerListenInfoBuilder {
  typedef WebRtcServerListenInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(FBS::Worker::TransportProtocol protocol) {
    fbb_.AddElement<uint8_t>(WebRtcServerListenInfo::VT_PROTOCOL, static_cast<uint8_t>(protocol), 1);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(WebRtcServerListenInfo::VT_IP, ip);
  }
  void add_announcedIp(flatbuffers::Offset<flatbuffers::String> announcedIp) {
    fbb_.AddOffset(WebRtcServerListenInfo::VT_ANNOUNCEDIP, announcedIp);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(WebRtcServerListenInfo::VT_PORT, port, 0);
  }
  explicit WebRtcServerListenInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcServerListenInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcServerListenInfo>(end);
    fbb_.Required(o, WebRtcServerListenInfo::VT_IP);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcServerListenInfo> CreateWebRtcServerListenInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Worker::TransportProtocol protocol = FBS::Worker::TransportProtocol::UDP,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    flatbuffers::Offset<flatbuffers::String> announcedIp = 0,
    uint16_t port = 0) {
  WebRtcServerListenInfoBuilder builder_(_fbb);
  builder_.add_announcedIp(announcedIp);
  builder_.add_ip(ip);
  builder_.add_port(port);
  builder_.add_protocol(protocol);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebRtcServerListenInfo> CreateWebRtcServerListenInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Worker::TransportProtocol protocol = FBS::Worker::TransportProtocol::UDP,
    const char *ip = nullptr,
    const char *announcedIp = nullptr,
    uint16_t port = 0) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  auto announcedIp__ = announcedIp ? _fbb.CreateString(announcedIp) : 0;
  return FBS::Worker::CreateWebRtcServerListenInfo(
      _fbb,
      protocol,
      ip__,
      announcedIp__,
      port);
}

struct CreateWebRtcServerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateWebRtcServerRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CreateWebRtcServerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEBRTCSERVERID = 4,
    VT_LISTENINFOS = 6
  };
  const flatbuffers::String *webRtcServerId() const {
    return GetPointer<const flatbuffers::String *>(VT_WEBRTCSERVERID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>> *listenInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>> *>(VT_LISTENINFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEBRTCSERVERID) &&
           verifier.VerifyString(webRtcServerId()) &&
           VerifyOffset(verifier, VT_LISTENINFOS) &&
           verifier.VerifyVector(listenInfos()) &&
           verifier.VerifyVectorOfTables(listenInfos()) &&
           verifier.EndTable();
  }
};

struct CreateWebRtcServerRequestBuilder {
  typedef CreateWebRtcServerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_webRtcServerId(flatbuffers::Offset<flatbuffers::String> webRtcServerId) {
    fbb_.AddOffset(CreateWebRtcServerRequest::VT_WEBRTCSERVERID, webRtcServerId);
  }
  void add_listenInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>>> listenInfos) {
    fbb_.AddOffset(CreateWebRtcServerRequest::VT_LISTENINFOS, listenInfos);
  }
  explicit CreateWebRtcServerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreateWebRtcServerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreateWebRtcServerRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateWebRtcServerRequest> CreateCreateWebRtcServerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> webRtcServerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>>> listenInfos = 0) {
  CreateWebRtcServerRequestBuilder builder_(_fbb);
  builder_.add_listenInfos(listenInfos);
  builder_.add_webRtcServerId(webRtcServerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateWebRtcServerRequest> CreateCreateWebRtcServerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *webRtcServerId = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>> *listenInfos = nullptr) {
  auto webRtcServerId__ = webRtcServerId ? _fbb.CreateString(webRtcServerId) : 0;
  auto listenInfos__ = listenInfos ? _fbb.CreateVector<flatbuffers::Offset<FBS::Worker::WebRtcServerListenInfo>>(*listenInfos) : 0;
  return FBS::Worker::CreateCreateWebRtcServerRequest(
      _fbb,
      webRtcServerId__,
      listenInfos__);
}

inline const flatbuffers::TypeTable *TransportProtocolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Worker::TransportProtocolTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "UDP",
    "TCP"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChannelMessageHandlersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "channelRequestHandlers",
    "payloadchannelRequestHandlers",
    "payloadchannelNotificationHandlers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WorkerDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Worker::ChannelMessageHandlersTypeTable
  };
  static const char * const names[] = {
    "pid",
    "webrtcServerIds",
    "routerIds",
    "channelMessageHandlers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResourceUsageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "ruUtime",
    "ruStime",
    "ruMaxrss",
    "ruIxrss",
    "ruIdrss",
    "ruIsrss",
    "ruMinflt",
    "ruMajflt",
    "ruNswap",
    "ruInblock",
    "ruOublock",
    "ruMsgsnd",
    "ruMsgrcv",
    "ruNsignals",
    "ruNvcsw",
    "ruNivcsw"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 16, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UpdateableSettingsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "logLevel",
    "logTags"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcServerListenInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Worker::TransportProtocolTypeTable
  };
  static const char * const names[] = {
    "protocol",
    "ip",
    "announcedIp",
    "port"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CreateWebRtcServerRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Worker::WebRtcServerListenInfoTypeTable
  };
  static const char * const names[] = {
    "webRtcServerId",
    "listenInfos"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const FBS::Worker::WorkerDump *GetWorkerDump(const void *buf) {
  return flatbuffers::GetRoot<FBS::Worker::WorkerDump>(buf);
}

inline const FBS::Worker::WorkerDump *GetSizePrefixedWorkerDump(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FBS::Worker::WorkerDump>(buf);
}

inline bool VerifyWorkerDumpBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBS::Worker::WorkerDump>(nullptr);
}

inline bool VerifySizePrefixedWorkerDumpBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FBS::Worker::WorkerDump>(nullptr);
}

inline void FinishWorkerDumpBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::Worker::WorkerDump> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorkerDumpBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::Worker::WorkerDump> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Worker
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_WORKER_FBS_WORKER_H_
