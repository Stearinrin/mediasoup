// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
#define FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_

#include "flatbuffers/flatbuffers.h"

namespace FBS {
namespace RtpParameters {

struct Boolean;
struct BooleanBuilder;

struct Integer;
struct IntegerBuilder;

struct IntegerArray;
struct IntegerArrayBuilder;

struct Double;
struct DoubleBuilder;

struct String;
struct StringBuilder;

struct Parameter;
struct ParameterBuilder;

struct RtcpFeedback;
struct RtcpFeedbackBuilder;

struct RtpCodecParameters;
struct RtpCodecParametersBuilder;

struct RtpHeaderExtensionParameters;
struct RtpHeaderExtensionParametersBuilder;

struct Rtx;
struct RtxBuilder;

struct RtpEncodingParameters;
struct RtpEncodingParametersBuilder;

struct RtcpParameters;
struct RtcpParametersBuilder;

struct RtpParameters;
struct RtpParametersBuilder;

inline const flatbuffers::TypeTable *BooleanTypeTable();

inline const flatbuffers::TypeTable *IntegerTypeTable();

inline const flatbuffers::TypeTable *IntegerArrayTypeTable();

inline const flatbuffers::TypeTable *DoubleTypeTable();

inline const flatbuffers::TypeTable *StringTypeTable();

inline const flatbuffers::TypeTable *ParameterTypeTable();

inline const flatbuffers::TypeTable *RtcpFeedbackTypeTable();

inline const flatbuffers::TypeTable *RtpCodecParametersTypeTable();

inline const flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable();

inline const flatbuffers::TypeTable *RtxTypeTable();

inline const flatbuffers::TypeTable *RtpEncodingParametersTypeTable();

inline const flatbuffers::TypeTable *RtcpParametersTypeTable();

inline const flatbuffers::TypeTable *RtpParametersTypeTable();

enum MediaKind : uint8_t {
  MediaKind_AUDIO = 0,
  MediaKind_VIDEO = 1,
  MediaKind_MIN = MediaKind_AUDIO,
  MediaKind_MAX = MediaKind_VIDEO
};

inline const MediaKind (&EnumValuesMediaKind())[2] {
  static const MediaKind values[] = {
    MediaKind_AUDIO,
    MediaKind_VIDEO
  };
  return values;
}

inline const char * const *EnumNamesMediaKind() {
  static const char * const names[3] = {
    "AUDIO",
    "VIDEO",
    nullptr
  };
  return names;
}

inline const char *EnumNameMediaKind(MediaKind e) {
  if (flatbuffers::IsOutRange(e, MediaKind_AUDIO, MediaKind_VIDEO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMediaKind()[index];
}

enum Type : uint8_t {
  Type_NONE = 0,
  Type_SIMPLE = 1,
  Type_SIMULCAST = 2,
  Type_SVC = 3,
  Type_PIPE = 4,
  Type_MIN = Type_NONE,
  Type_MAX = Type_PIPE
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_NONE,
    Type_SIMPLE,
    Type_SIMULCAST,
    Type_SVC,
    Type_PIPE
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[6] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_NONE, Type_PIPE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum Value : uint8_t {
  Value_NONE = 0,
  Value_Boolean = 1,
  Value_Integer = 2,
  Value_Double = 3,
  Value_String = 4,
  Value_IntegerArray = 5,
  Value_MIN = Value_NONE,
  Value_MAX = Value_IntegerArray
};

inline const Value (&EnumValuesValue())[6] {
  static const Value values[] = {
    Value_NONE,
    Value_Boolean,
    Value_Integer,
    Value_Double,
    Value_String,
    Value_IntegerArray
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[7] = {
    "NONE",
    "Boolean",
    "Integer",
    "Double",
    "String",
    "IntegerArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value_NONE, Value_IntegerArray)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueTraits<FBS::RtpParameters::Boolean> {
  static const Value enum_value = Value_Boolean;
};

template<> struct ValueTraits<FBS::RtpParameters::Integer> {
  static const Value enum_value = Value_Integer;
};

template<> struct ValueTraits<FBS::RtpParameters::Double> {
  static const Value enum_value = Value_Double;
};

template<> struct ValueTraits<FBS::RtpParameters::String> {
  static const Value enum_value = Value_String;
};

template<> struct ValueTraits<FBS::RtpParameters::IntegerArray> {
  static const Value enum_value = Value_IntegerArray;
};

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Boolean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BooleanBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BooleanTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanBuilder {
  typedef Boolean Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(Boolean::VT_VALUE, value, 0);
  }
  explicit BooleanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Boolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Boolean>(end);
    return o;
  }
};

inline flatbuffers::Offset<Boolean> CreateBoolean(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  BooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Integer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntegerBuilder {
  typedef Integer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Integer::VT_VALUE, value, 0);
  }
  explicit IntegerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Integer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Integer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Integer> CreateInteger(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntegerBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntegerArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntegerArrayBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntegerArrayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct IntegerArrayBuilder {
  typedef IntegerArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(IntegerArray::VT_VALUE, value);
  }
  explicit IntegerArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntegerArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntegerArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntegerArray> CreateIntegerArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  IntegerArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntegerArray> CreateIntegerArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return FBS::RtpParameters::CreateIntegerArray(
      _fbb,
      value__);
}

struct Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DoubleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleBuilder {
  typedef Double Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Double::VT_VALUE, value, 0.0);
  }
  explicit DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Double> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Double>(end);
    return o;
  }
};

inline flatbuffers::Offset<Double> CreateDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return StringTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(String::VT_VALUE, value);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return FBS::RtpParameters::CreateString(
      _fbb,
      value__);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParameterBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParameterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  FBS::RtpParameters::Value value_type() const {
    return static_cast<FBS::RtpParameters::Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const FBS::RtpParameters::Boolean *value_as_Boolean() const {
    return value_type() == FBS::RtpParameters::Value_Boolean ? static_cast<const FBS::RtpParameters::Boolean *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Integer *value_as_Integer() const {
    return value_type() == FBS::RtpParameters::Value_Integer ? static_cast<const FBS::RtpParameters::Integer *>(value()) : nullptr;
  }
  const FBS::RtpParameters::Double *value_as_Double() const {
    return value_type() == FBS::RtpParameters::Value_Double ? static_cast<const FBS::RtpParameters::Double *>(value()) : nullptr;
  }
  const FBS::RtpParameters::String *value_as_String() const {
    return value_type() == FBS::RtpParameters::Value_String ? static_cast<const FBS::RtpParameters::String *>(value()) : nullptr;
  }
  const FBS::RtpParameters::IntegerArray *value_as_IntegerArray() const {
    return value_type() == FBS::RtpParameters::Value_IntegerArray ? static_cast<const FBS::RtpParameters::IntegerArray *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::RtpParameters::Boolean *Parameter::value_as<FBS::RtpParameters::Boolean>() const {
  return value_as_Boolean();
}

template<> inline const FBS::RtpParameters::Integer *Parameter::value_as<FBS::RtpParameters::Integer>() const {
  return value_as_Integer();
}

template<> inline const FBS::RtpParameters::Double *Parameter::value_as<FBS::RtpParameters::Double>() const {
  return value_as_Double();
}

template<> inline const FBS::RtpParameters::String *Parameter::value_as<FBS::RtpParameters::String>() const {
  return value_as_String();
}

template<> inline const FBS::RtpParameters::IntegerArray *Parameter::value_as<FBS::RtpParameters::IntegerArray>() const {
  return value_as_IntegerArray();
}

struct ParameterBuilder {
  typedef Parameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Parameter::VT_NAME, name);
  }
  void add_value_type(FBS::RtpParameters::Value value_type) {
    fbb_.AddElement<uint8_t>(Parameter::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Parameter::VT_VALUE, value);
  }
  explicit ParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parameter> CreateParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value_NONE,
    flatbuffers::Offset<void> value = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Parameter> CreateParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    FBS::RtpParameters::Value value_type = FBS::RtpParameters::Value_NONE,
    flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return FBS::RtpParameters::CreateParameter(
      _fbb,
      name__,
      value_type,
      value);
}

struct RtcpFeedback FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtcpFeedbackBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpFeedbackTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PARAMETER = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           verifier.EndTable();
  }
};

struct RtcpFeedbackBuilder {
  typedef RtcpFeedback Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(RtcpFeedback::VT_TYPE, type);
  }
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(RtcpFeedback::VT_PARAMETER, parameter);
  }
  explicit RtcpFeedbackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtcpFeedback> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtcpFeedback>(end);
    fbb_.Required(o, RtcpFeedback::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedback(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> parameter = 0) {
  RtcpFeedbackBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtcpFeedback> CreateRtcpFeedbackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *parameter = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  return FBS::RtpParameters::CreateRtcpFeedback(
      _fbb,
      type__,
      parameter__);
}

struct RtpCodecParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpCodecParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpCodecParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIME_TYPE = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_CLOCK_RATE = 8,
    VT_CHANNELS = 10,
    VT_PARAMETERS = 12,
    VT_RTCP_FEEDBACK = 14
  };
  const flatbuffers::String *mime_type() const {
    return GetPointer<const flatbuffers::String *>(VT_MIME_TYPE);
  }
  uint8_t payload_type() const {
    return GetField<uint8_t>(VT_PAYLOAD_TYPE, 0);
  }
  uint32_t clock_rate() const {
    return GetField<uint32_t>(VT_CLOCK_RATE, 0);
  }
  uint8_t channels() const {
    return GetField<uint8_t>(VT_CHANNELS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcp_feedback() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *>(VT_RTCP_FEEDBACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MIME_TYPE) &&
           verifier.VerifyString(mime_type()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_CLOCK_RATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_RTCP_FEEDBACK) &&
           verifier.VerifyVector(rtcp_feedback()) &&
           verifier.VerifyVectorOfTables(rtcp_feedback()) &&
           verifier.EndTable();
  }
};

struct RtpCodecParametersBuilder {
  typedef RtpCodecParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mime_type(flatbuffers::Offset<flatbuffers::String> mime_type) {
    fbb_.AddOffset(RtpCodecParameters::VT_MIME_TYPE, mime_type);
  }
  void add_payload_type(uint8_t payload_type) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_PAYLOAD_TYPE, payload_type, 0);
  }
  void add_clock_rate(uint32_t clock_rate) {
    fbb_.AddElement<uint32_t>(RtpCodecParameters::VT_CLOCK_RATE, clock_rate, 0);
  }
  void add_channels(uint8_t channels) {
    fbb_.AddElement<uint8_t>(RtpCodecParameters::VT_CHANNELS, channels, 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters) {
    fbb_.AddOffset(RtpCodecParameters::VT_PARAMETERS, parameters);
  }
  void add_rtcp_feedback(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcp_feedback) {
    fbb_.AddOffset(RtpCodecParameters::VT_RTCP_FEEDBACK, rtcp_feedback);
  }
  explicit RtpCodecParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpCodecParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpCodecParameters>(end);
    fbb_.Required(o, RtpCodecParameters::VT_MIME_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mime_type = 0,
    uint8_t payload_type = 0,
    uint32_t clock_rate = 0,
    uint8_t channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>> parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>> rtcp_feedback = 0) {
  RtpCodecParametersBuilder builder_(_fbb);
  builder_.add_rtcp_feedback(rtcp_feedback);
  builder_.add_parameters(parameters);
  builder_.add_clock_rate(clock_rate);
  builder_.add_mime_type(mime_type);
  builder_.add_channels(channels);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpCodecParameters> CreateRtpCodecParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime_type = nullptr,
    uint8_t payload_type = 0,
    uint32_t clock_rate = 0,
    uint8_t channels = 0,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::Parameter>> *parameters = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>> *rtcp_feedback = nullptr) {
  auto mime_type__ = mime_type ? _fbb.CreateString(mime_type) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::Parameter>>(*parameters) : 0;
  auto rtcp_feedback__ = rtcp_feedback ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtcpFeedback>>(*rtcp_feedback) : 0;
  return FBS::RtpParameters::CreateRtpCodecParameters(
      _fbb,
      mime_type__,
      payload_type,
      clock_rate,
      channels,
      parameters__,
      rtcp_feedback__);
}

struct RtpHeaderExtensionParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpHeaderExtensionParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpHeaderExtensionParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URI = 4,
    VT_ID = 6,
    VT_ENCRYPT = 8,
    VT_PARAMETERS = 10
  };
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  bool encrypt() const {
    return GetField<uint8_t>(VT_ENCRYPT, 0) != 0;
  }
  const flatbuffers::String *parameters() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPT, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyString(parameters()) &&
           verifier.EndTable();
  }
};

struct RtpHeaderExtensionParametersBuilder {
  typedef RtpHeaderExtensionParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_URI, uri);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ID, id, 0);
  }
  void add_encrypt(bool encrypt) {
    fbb_.AddElement<uint8_t>(RtpHeaderExtensionParameters::VT_ENCRYPT, static_cast<uint8_t>(encrypt), 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::String> parameters) {
    fbb_.AddOffset(RtpHeaderExtensionParameters::VT_PARAMETERS, parameters);
  }
  explicit RtpHeaderExtensionParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpHeaderExtensionParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpHeaderExtensionParameters>(end);
    fbb_.Required(o, RtpHeaderExtensionParameters::VT_URI);
    return o;
  }
};

inline flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uri = 0,
    uint8_t id = 0,
    bool encrypt = false,
    flatbuffers::Offset<flatbuffers::String> parameters = 0) {
  RtpHeaderExtensionParametersBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_uri(uri);
  builder_.add_encrypt(encrypt);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpHeaderExtensionParameters> CreateRtpHeaderExtensionParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uri = nullptr,
    uint8_t id = 0,
    bool encrypt = false,
    const char *parameters = nullptr) {
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto parameters__ = parameters ? _fbb.CreateString(parameters) : 0;
  return FBS::RtpParameters::CreateRtpHeaderExtensionParameters(
      _fbb,
      uri__,
      id,
      encrypt,
      parameters__);
}

struct Rtx FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtxBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           verifier.EndTable();
  }
};

struct RtxBuilder {
  typedef Rtx Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Rtx::VT_SSRC, ssrc, 0);
  }
  explicit RtxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rtx> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rtx>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rtx> CreateRtx(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0) {
  RtxBuilder builder_(_fbb);
  builder_.add_ssrc(ssrc);
  return builder_.Finish();
}

struct RtpEncodingParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpEncodingParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpEncodingParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRC = 4,
    VT_RID = 6,
    VT_CODEC_PAYLOAD_TYPE = 8,
    VT_RTX = 10,
    VT_DTX = 12,
    VT_SCALABILITY_MODE = 14,
    VT_SCALE_RESOLUTION_DOWN_BY = 16,
    VT_MAX_BITRATE = 18
  };
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  const flatbuffers::String *rid() const {
    return GetPointer<const flatbuffers::String *>(VT_RID);
  }
  uint8_t codec_payload_type() const {
    return GetField<uint8_t>(VT_CODEC_PAYLOAD_TYPE, 0);
  }
  const FBS::RtpParameters::Rtx *rtx() const {
    return GetPointer<const FBS::RtpParameters::Rtx *>(VT_RTX);
  }
  bool dtx() const {
    return GetField<uint8_t>(VT_DTX, 0) != 0;
  }
  const flatbuffers::String *scalability_mode() const {
    return GetPointer<const flatbuffers::String *>(VT_SCALABILITY_MODE);
  }
  uint8_t scale_resolution_down_by() const {
    return GetField<uint8_t>(VT_SCALE_RESOLUTION_DOWN_BY, 0);
  }
  uint32_t max_bitrate() const {
    return GetField<uint32_t>(VT_MAX_BITRATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyField<uint8_t>(verifier, VT_CODEC_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_RTX) &&
           verifier.VerifyTable(rtx()) &&
           VerifyField<uint8_t>(verifier, VT_DTX, 1) &&
           VerifyOffset(verifier, VT_SCALABILITY_MODE) &&
           verifier.VerifyString(scalability_mode()) &&
           VerifyField<uint8_t>(verifier, VT_SCALE_RESOLUTION_DOWN_BY, 1) &&
           VerifyField<uint32_t>(verifier, VT_MAX_BITRATE, 4) &&
           verifier.EndTable();
  }
};

struct RtpEncodingParametersBuilder {
  typedef RtpEncodingParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_SSRC, ssrc, 0);
  }
  void add_rid(flatbuffers::Offset<flatbuffers::String> rid) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RID, rid);
  }
  void add_codec_payload_type(uint8_t codec_payload_type) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_CODEC_PAYLOAD_TYPE, codec_payload_type, 0);
  }
  void add_rtx(flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx) {
    fbb_.AddOffset(RtpEncodingParameters::VT_RTX, rtx);
  }
  void add_dtx(bool dtx) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_DTX, static_cast<uint8_t>(dtx), 0);
  }
  void add_scalability_mode(flatbuffers::Offset<flatbuffers::String> scalability_mode) {
    fbb_.AddOffset(RtpEncodingParameters::VT_SCALABILITY_MODE, scalability_mode);
  }
  void add_scale_resolution_down_by(uint8_t scale_resolution_down_by) {
    fbb_.AddElement<uint8_t>(RtpEncodingParameters::VT_SCALE_RESOLUTION_DOWN_BY, scale_resolution_down_by, 0);
  }
  void add_max_bitrate(uint32_t max_bitrate) {
    fbb_.AddElement<uint32_t>(RtpEncodingParameters::VT_MAX_BITRATE, max_bitrate, 0);
  }
  explicit RtpEncodingParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpEncodingParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpEncodingParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    flatbuffers::Offset<flatbuffers::String> rid = 0,
    uint8_t codec_payload_type = 0,
    flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    flatbuffers::Offset<flatbuffers::String> scalability_mode = 0,
    uint8_t scale_resolution_down_by = 0,
    uint32_t max_bitrate = 0) {
  RtpEncodingParametersBuilder builder_(_fbb);
  builder_.add_max_bitrate(max_bitrate);
  builder_.add_scalability_mode(scalability_mode);
  builder_.add_rtx(rtx);
  builder_.add_rid(rid);
  builder_.add_ssrc(ssrc);
  builder_.add_scale_resolution_down_by(scale_resolution_down_by);
  builder_.add_dtx(dtx);
  builder_.add_codec_payload_type(codec_payload_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpEncodingParameters> CreateRtpEncodingParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ssrc = 0,
    const char *rid = nullptr,
    uint8_t codec_payload_type = 0,
    flatbuffers::Offset<FBS::RtpParameters::Rtx> rtx = 0,
    bool dtx = false,
    const char *scalability_mode = nullptr,
    uint8_t scale_resolution_down_by = 0,
    uint32_t max_bitrate = 0) {
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto scalability_mode__ = scalability_mode ? _fbb.CreateString(scalability_mode) : 0;
  return FBS::RtpParameters::CreateRtpEncodingParameters(
      _fbb,
      ssrc,
      rid__,
      codec_payload_type,
      rtx,
      dtx,
      scalability_mode__,
      scale_resolution_down_by,
      max_bitrate);
}

struct RtcpParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtcpParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtcpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CNAME = 4,
    VT_REDUCED_SIZE = 6,
    VT_MUX = 8
  };
  const flatbuffers::String *cname() const {
    return GetPointer<const flatbuffers::String *>(VT_CNAME);
  }
  bool reduced_size() const {
    return GetField<uint8_t>(VT_REDUCED_SIZE, 1) != 0;
  }
  bool mux() const {
    return GetField<uint8_t>(VT_MUX, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint8_t>(verifier, VT_REDUCED_SIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MUX, 1) &&
           verifier.EndTable();
  }
};

struct RtcpParametersBuilder {
  typedef RtcpParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cname(flatbuffers::Offset<flatbuffers::String> cname) {
    fbb_.AddOffset(RtcpParameters::VT_CNAME, cname);
  }
  void add_reduced_size(bool reduced_size) {
    fbb_.AddElement<uint8_t>(RtcpParameters::VT_REDUCED_SIZE, static_cast<uint8_t>(reduced_size), 1);
  }
  void add_mux(bool mux) {
    fbb_.AddElement<uint8_t>(RtcpParameters::VT_MUX, static_cast<uint8_t>(mux), 1);
  }
  explicit RtcpParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtcpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtcpParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<RtcpParameters> CreateRtcpParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cname = 0,
    bool reduced_size = true,
    bool mux = true) {
  RtcpParametersBuilder builder_(_fbb);
  builder_.add_cname(cname);
  builder_.add_mux(mux);
  builder_.add_reduced_size(reduced_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtcpParameters> CreateRtcpParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cname = nullptr,
    bool reduced_size = true,
    bool mux = true) {
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtpParameters::CreateRtcpParameters(
      _fbb,
      cname__,
      reduced_size,
      mux);
}

struct RtpParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MID = 4,
    VT_CODECS = 6,
    VT_HEADER_EXTENSIONS = 8,
    VT_ENCODINGS = 10,
    VT_RTCP = 12
  };
  const flatbuffers::String *mid() const {
    return GetPointer<const flatbuffers::String *>(VT_MID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *>(VT_CODECS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *header_extensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *>(VT_HEADER_EXTENSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_ENCODINGS);
  }
  const FBS::RtpParameters::RtcpParameters *rtcp() const {
    return GetPointer<const FBS::RtpParameters::RtcpParameters *>(VT_RTCP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MID) &&
           verifier.VerifyString(mid()) &&
           VerifyOffsetRequired(verifier, VT_CODECS) &&
           verifier.VerifyVector(codecs()) &&
           verifier.VerifyVectorOfTables(codecs()) &&
           VerifyOffset(verifier, VT_HEADER_EXTENSIONS) &&
           verifier.VerifyVector(header_extensions()) &&
           verifier.VerifyVectorOfTables(header_extensions()) &&
           VerifyOffset(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           verifier.VerifyVectorOfTables(encodings()) &&
           VerifyOffset(verifier, VT_RTCP) &&
           verifier.VerifyTable(rtcp()) &&
           verifier.EndTable();
  }
};

struct RtpParametersBuilder {
  typedef RtpParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mid(flatbuffers::Offset<flatbuffers::String> mid) {
    fbb_.AddOffset(RtpParameters::VT_MID, mid);
  }
  void add_codecs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs) {
    fbb_.AddOffset(RtpParameters::VT_CODECS, codecs);
  }
  void add_header_extensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> header_extensions) {
    fbb_.AddOffset(RtpParameters::VT_HEADER_EXTENSIONS, header_extensions);
  }
  void add_encodings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings) {
    fbb_.AddOffset(RtpParameters::VT_ENCODINGS, encodings);
  }
  void add_rtcp(flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp) {
    fbb_.AddOffset(RtpParameters::VT_RTCP, rtcp);
  }
  explicit RtpParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpParameters>(end);
    fbb_.Required(o, RtpParameters::VT_CODECS);
    return o;
  }
};

inline flatbuffers::Offset<RtpParameters> CreateRtpParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>> codecs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>> header_extensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> encodings = 0,
    flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  RtpParametersBuilder builder_(_fbb);
  builder_.add_rtcp(rtcp);
  builder_.add_encodings(encodings);
  builder_.add_header_extensions(header_extensions);
  builder_.add_codecs(codecs);
  builder_.add_mid(mid);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpParameters> CreateRtpParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mid = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>> *codecs = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>> *header_extensions = nullptr,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *encodings = nullptr,
    flatbuffers::Offset<FBS::RtpParameters::RtcpParameters> rtcp = 0) {
  auto mid__ = mid ? _fbb.CreateString(mid) : 0;
  auto codecs__ = codecs ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpCodecParameters>>(*codecs) : 0;
  auto header_extensions__ = header_extensions ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpHeaderExtensionParameters>>(*header_extensions) : 0;
  auto encodings__ = encodings ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*encodings) : 0;
  return FBS::RtpParameters::CreateRtpParameters(
      _fbb,
      mid__,
      codecs__,
      header_extensions__,
      encodings__,
      rtcp);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value_NONE: {
      return true;
    }
    case Value_Boolean: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Boolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Integer: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Integer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_Double: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::Double *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_String: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value_IntegerArray: {
      auto ptr = reinterpret_cast<const FBS::RtpParameters::IntegerArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *MediaKindTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable
  };
  static const char * const names[] = {
    "AUDIO",
    "VIDEO"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::TypeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "SIMPLE",
    "SIMULCAST",
    "SVC",
    "PIPE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ValueTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::BooleanTypeTable,
    FBS::RtpParameters::IntegerTypeTable,
    FBS::RtpParameters::DoubleTypeTable,
    FBS::RtpParameters::StringTypeTable,
    FBS::RtpParameters::IntegerArrayTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Boolean",
    "Integer",
    "Double",
    "String",
    "IntegerArray"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BooleanTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntegerArrayTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DoubleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *StringTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ValueTypeTable
  };
  static const char * const names[] = {
    "name",
    "value_type",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtcpFeedbackTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "type",
    "parameter"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpCodecParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::ParameterTypeTable,
    FBS::RtpParameters::RtcpFeedbackTypeTable
  };
  static const char * const names[] = {
    "mime_type",
    "payload_type",
    "clock_rate",
    "channels",
    "parameters",
    "rtcp_feedback"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpHeaderExtensionParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "uri",
    "id",
    "encrypt",
    "parameters"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "ssrc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpEncodingParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtxTypeTable
  };
  static const char * const names[] = {
    "ssrc",
    "rid",
    "codec_payload_type",
    "rtx",
    "dtx",
    "scalability_mode",
    "scale_resolution_down_by",
    "max_bitrate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtcpParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "cname",
    "reduced_size",
    "mux"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::RtpCodecParametersTypeTable,
    FBS::RtpParameters::RtpHeaderExtensionParametersTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::RtpParameters::RtcpParametersTypeTable
  };
  static const char * const names[] = {
    "mid",
    "codecs",
    "header_extensions",
    "encodings",
    "rtcp"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const FBS::RtpParameters::RtpParameters *GetRtpParameters(const void *buf) {
  return flatbuffers::GetRoot<FBS::RtpParameters::RtpParameters>(buf);
}

inline const FBS::RtpParameters::RtpParameters *GetSizePrefixedRtpParameters(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FBS::RtpParameters::RtpParameters>(buf);
}

inline bool VerifyRtpParametersBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBS::RtpParameters::RtpParameters>(nullptr);
}

inline bool VerifySizePrefixedRtpParametersBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FBS::RtpParameters::RtpParameters>(nullptr);
}

inline void FinishRtpParametersBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRtpParametersBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace RtpParameters
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTPPARAMETERS_FBS_RTPPARAMETERS_H_
