// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_
#define FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "rtxStream_generated.h"

namespace FBS {
namespace RtpStream {

struct Params;
struct ParamsBuilder;

struct Dump;
struct DumpBuilder;

inline const flatbuffers::TypeTable *ParamsTypeTable();

inline const flatbuffers::TypeTable *DumpTypeTable();

struct Params FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParamsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParamsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCODINGIDX = 4,
    VT_SSRC = 6,
    VT_PAYLOADTYPE = 8,
    VT_MIMETYPE = 10,
    VT_CLOCKRATE = 12,
    VT_RID = 14,
    VT_CNAME = 16,
    VT_RTXSSRC = 18,
    VT_RTXPAYLOADTYPE = 20,
    VT_USENACK = 22,
    VT_USEPLI = 24,
    VT_USEFIR = 26,
    VT_USEINBANDFEC = 28,
    VT_USEDTX = 30,
    VT_SPATIALLAYERS = 32,
    VT_TEMPORALLAYERS = 34
  };
  uint32_t encodingIdx() const {
    return GetField<uint32_t>(VT_ENCODINGIDX, 0);
  }
  uint32_t ssrc() const {
    return GetField<uint32_t>(VT_SSRC, 0);
  }
  uint8_t payloadType() const {
    return GetField<uint8_t>(VT_PAYLOADTYPE, 0);
  }
  const flatbuffers::String *mimeType() const {
    return GetPointer<const flatbuffers::String *>(VT_MIMETYPE);
  }
  uint32_t clockRate() const {
    return GetField<uint32_t>(VT_CLOCKRATE, 0);
  }
  const flatbuffers::String *rid() const {
    return GetPointer<const flatbuffers::String *>(VT_RID);
  }
  const flatbuffers::String *cname() const {
    return GetPointer<const flatbuffers::String *>(VT_CNAME);
  }
  flatbuffers::Optional<uint32_t> rtxSsrc() const {
    return GetOptional<uint32_t, uint32_t>(VT_RTXSSRC);
  }
  flatbuffers::Optional<uint8_t> rtxPayloadType() const {
    return GetOptional<uint8_t, uint8_t>(VT_RTXPAYLOADTYPE);
  }
  bool useNack() const {
    return GetField<uint8_t>(VT_USENACK, 0) != 0;
  }
  bool usePli() const {
    return GetField<uint8_t>(VT_USEPLI, 0) != 0;
  }
  bool useFir() const {
    return GetField<uint8_t>(VT_USEFIR, 0) != 0;
  }
  bool useInBandFec() const {
    return GetField<uint8_t>(VT_USEINBANDFEC, 0) != 0;
  }
  bool useDtx() const {
    return GetField<uint8_t>(VT_USEDTX, 0) != 0;
  }
  uint8_t spatialLayers() const {
    return GetField<uint8_t>(VT_SPATIALLAYERS, 0);
  }
  uint8_t temporalLayers() const {
    return GetField<uint8_t>(VT_TEMPORALLAYERS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ENCODINGIDX, 4) &&
           VerifyField<uint32_t>(verifier, VT_SSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOADTYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_MIMETYPE) &&
           verifier.VerifyString(mimeType()) &&
           VerifyField<uint32_t>(verifier, VT_CLOCKRATE, 4) &&
           VerifyOffset(verifier, VT_RID) &&
           verifier.VerifyString(rid()) &&
           VerifyOffsetRequired(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint32_t>(verifier, VT_RTXSSRC, 4) &&
           VerifyField<uint8_t>(verifier, VT_RTXPAYLOADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_USENACK, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEPLI, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEFIR, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEINBANDFEC, 1) &&
           VerifyField<uint8_t>(verifier, VT_USEDTX, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPATIALLAYERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEMPORALLAYERS, 1) &&
           verifier.EndTable();
  }
};

struct ParamsBuilder {
  typedef Params Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_encodingIdx(uint32_t encodingIdx) {
    fbb_.AddElement<uint32_t>(Params::VT_ENCODINGIDX, encodingIdx, 0);
  }
  void add_ssrc(uint32_t ssrc) {
    fbb_.AddElement<uint32_t>(Params::VT_SSRC, ssrc, 0);
  }
  void add_payloadType(uint8_t payloadType) {
    fbb_.AddElement<uint8_t>(Params::VT_PAYLOADTYPE, payloadType, 0);
  }
  void add_mimeType(flatbuffers::Offset<flatbuffers::String> mimeType) {
    fbb_.AddOffset(Params::VT_MIMETYPE, mimeType);
  }
  void add_clockRate(uint32_t clockRate) {
    fbb_.AddElement<uint32_t>(Params::VT_CLOCKRATE, clockRate, 0);
  }
  void add_rid(flatbuffers::Offset<flatbuffers::String> rid) {
    fbb_.AddOffset(Params::VT_RID, rid);
  }
  void add_cname(flatbuffers::Offset<flatbuffers::String> cname) {
    fbb_.AddOffset(Params::VT_CNAME, cname);
  }
  void add_rtxSsrc(uint32_t rtxSsrc) {
    fbb_.AddElement<uint32_t>(Params::VT_RTXSSRC, rtxSsrc);
  }
  void add_rtxPayloadType(uint8_t rtxPayloadType) {
    fbb_.AddElement<uint8_t>(Params::VT_RTXPAYLOADTYPE, rtxPayloadType);
  }
  void add_useNack(bool useNack) {
    fbb_.AddElement<uint8_t>(Params::VT_USENACK, static_cast<uint8_t>(useNack), 0);
  }
  void add_usePli(bool usePli) {
    fbb_.AddElement<uint8_t>(Params::VT_USEPLI, static_cast<uint8_t>(usePli), 0);
  }
  void add_useFir(bool useFir) {
    fbb_.AddElement<uint8_t>(Params::VT_USEFIR, static_cast<uint8_t>(useFir), 0);
  }
  void add_useInBandFec(bool useInBandFec) {
    fbb_.AddElement<uint8_t>(Params::VT_USEINBANDFEC, static_cast<uint8_t>(useInBandFec), 0);
  }
  void add_useDtx(bool useDtx) {
    fbb_.AddElement<uint8_t>(Params::VT_USEDTX, static_cast<uint8_t>(useDtx), 0);
  }
  void add_spatialLayers(uint8_t spatialLayers) {
    fbb_.AddElement<uint8_t>(Params::VT_SPATIALLAYERS, spatialLayers, 0);
  }
  void add_temporalLayers(uint8_t temporalLayers) {
    fbb_.AddElement<uint8_t>(Params::VT_TEMPORALLAYERS, temporalLayers, 0);
  }
  explicit ParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Params> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Params>(end);
    fbb_.Required(o, Params::VT_MIMETYPE);
    fbb_.Required(o, Params::VT_CNAME);
    return o;
  }
};

inline flatbuffers::Offset<Params> CreateParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t encodingIdx = 0,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    flatbuffers::Offset<flatbuffers::String> mimeType = 0,
    uint32_t clockRate = 0,
    flatbuffers::Offset<flatbuffers::String> rid = 0,
    flatbuffers::Offset<flatbuffers::String> cname = 0,
    flatbuffers::Optional<uint32_t> rtxSsrc = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> rtxPayloadType = flatbuffers::nullopt,
    bool useNack = false,
    bool usePli = false,
    bool useFir = false,
    bool useInBandFec = false,
    bool useDtx = false,
    uint8_t spatialLayers = 0,
    uint8_t temporalLayers = 0) {
  ParamsBuilder builder_(_fbb);
  if(rtxSsrc) { builder_.add_rtxSsrc(*rtxSsrc); }
  builder_.add_cname(cname);
  builder_.add_rid(rid);
  builder_.add_clockRate(clockRate);
  builder_.add_mimeType(mimeType);
  builder_.add_ssrc(ssrc);
  builder_.add_encodingIdx(encodingIdx);
  builder_.add_temporalLayers(temporalLayers);
  builder_.add_spatialLayers(spatialLayers);
  builder_.add_useDtx(useDtx);
  builder_.add_useInBandFec(useInBandFec);
  builder_.add_useFir(useFir);
  builder_.add_usePli(usePli);
  builder_.add_useNack(useNack);
  if(rtxPayloadType) { builder_.add_rtxPayloadType(*rtxPayloadType); }
  builder_.add_payloadType(payloadType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Params> CreateParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t encodingIdx = 0,
    uint32_t ssrc = 0,
    uint8_t payloadType = 0,
    const char *mimeType = nullptr,
    uint32_t clockRate = 0,
    const char *rid = nullptr,
    const char *cname = nullptr,
    flatbuffers::Optional<uint32_t> rtxSsrc = flatbuffers::nullopt,
    flatbuffers::Optional<uint8_t> rtxPayloadType = flatbuffers::nullopt,
    bool useNack = false,
    bool usePli = false,
    bool useFir = false,
    bool useInBandFec = false,
    bool useDtx = false,
    uint8_t spatialLayers = 0,
    uint8_t temporalLayers = 0) {
  auto mimeType__ = mimeType ? _fbb.CreateString(mimeType) : 0;
  auto rid__ = rid ? _fbb.CreateString(rid) : 0;
  auto cname__ = cname ? _fbb.CreateString(cname) : 0;
  return FBS::RtpStream::CreateParams(
      _fbb,
      encodingIdx,
      ssrc,
      payloadType,
      mimeType__,
      clockRate,
      rid__,
      cname__,
      rtxSsrc,
      rtxPayloadType,
      useNack,
      usePli,
      useFir,
      useInBandFec,
      useDtx,
      spatialLayers,
      temporalLayers);
}

struct Dump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMS = 4,
    VT_SCORE = 6,
    VT_RTXSTREAM = 8
  };
  const FBS::RtpStream::Params *params() const {
    return GetPointer<const FBS::RtpStream::Params *>(VT_PARAMS);
  }
  uint8_t score() const {
    return GetField<uint8_t>(VT_SCORE, 0);
  }
  const FBS::RtxStream::RtxDump *rtxStream() const {
    return GetPointer<const FBS::RtxStream::RtxDump *>(VT_RTXSTREAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyTable(params()) &&
           VerifyField<uint8_t>(verifier, VT_SCORE, 1) &&
           VerifyOffset(verifier, VT_RTXSTREAM) &&
           verifier.VerifyTable(rtxStream()) &&
           verifier.EndTable();
  }
};

struct DumpBuilder {
  typedef Dump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<FBS::RtpStream::Params> params) {
    fbb_.AddOffset(Dump::VT_PARAMS, params);
  }
  void add_score(uint8_t score) {
    fbb_.AddElement<uint8_t>(Dump::VT_SCORE, score, 0);
  }
  void add_rtxStream(flatbuffers::Offset<FBS::RtxStream::RtxDump> rtxStream) {
    fbb_.AddOffset(Dump::VT_RTXSTREAM, rtxStream);
  }
  explicit DumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dump>(end);
    fbb_.Required(o, Dump::VT_PARAMS);
    return o;
  }
};

inline flatbuffers::Offset<Dump> CreateDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::RtpStream::Params> params = 0,
    uint8_t score = 0,
    flatbuffers::Offset<FBS::RtxStream::RtxDump> rtxStream = 0) {
  DumpBuilder builder_(_fbb);
  builder_.add_rtxStream(rtxStream);
  builder_.add_params(params);
  builder_.add_score(score);
  return builder_.Finish();
}

inline const flatbuffers::TypeTable *ParamsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const char * const names[] = {
    "encodingIdx",
    "ssrc",
    "payloadType",
    "mimeType",
    "clockRate",
    "rid",
    "cname",
    "rtxSsrc",
    "rtxPayloadType",
    "useNack",
    "usePli",
    "useFir",
    "useInBandFec",
    "useDtx",
    "spatialLayers",
    "temporalLayers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 16, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpStream::ParamsTypeTable,
    FBS::RtxStream::RtxDumpTypeTable
  };
  static const char * const names[] = {
    "params",
    "score",
    "rtxStream"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace RtpStream
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_RTPSTREAM_FBS_RTPSTREAM_H_
