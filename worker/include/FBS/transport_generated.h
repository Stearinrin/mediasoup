// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
#define FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_

#include "flatbuffers/flatbuffers.h"

#include "consumer_generated.h"
#include "rtpParameters_generated.h"

namespace FBS {
namespace Transport {

struct ConsumeRequest;
struct ConsumeRequestBuilder;

struct ConsumeResponse;
struct ConsumeResponseBuilder;

inline const flatbuffers::TypeTable *ConsumeRequestTypeTable();

inline const flatbuffers::TypeTable *ConsumeResponseTypeTable();

struct ConsumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsumeRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSUMER_ID = 4,
    VT_PRODUCER_ID = 6,
    VT_KIND = 8,
    VT_RTP_PARAMETERS = 10,
    VT_TYPE = 12,
    VT_CONSUMABLE_RTP_ENCODINGS = 14,
    VT_PAUSED = 16,
    VT_PREFERRED_LAYERS = 18,
    VT_IGNORE_DTX = 20
  };
  const flatbuffers::String *consumer_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONSUMER_ID);
  }
  const flatbuffers::String *producer_id() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCER_ID);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const FBS::RtpParameters::RtpParameters *rtp_parameters() const {
    return GetPointer<const FBS::RtpParameters::RtpParameters *>(VT_RTP_PARAMETERS);
  }
  FBS::RtpParameters::Type type() const {
    return static_cast<FBS::RtpParameters::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumable_rtp_encodings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_CONSUMABLE_RTP_ENCODINGS);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  const FBS::Consumer::ConsumerLayers *preferred_layers() const {
    return GetStruct<const FBS::Consumer::ConsumerLayers *>(VT_PREFERRED_LAYERS);
  }
  bool ignore_dtx() const {
    return GetField<uint8_t>(VT_IGNORE_DTX, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSUMER_ID) &&
           verifier.VerifyString(consumer_id()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCER_ID) &&
           verifier.VerifyString(producer_id()) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_RTP_PARAMETERS) &&
           verifier.VerifyTable(rtp_parameters()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_CONSUMABLE_RTP_ENCODINGS) &&
           verifier.VerifyVector(consumable_rtp_encodings()) &&
           verifier.VerifyVectorOfTables(consumable_rtp_encodings()) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<FBS::Consumer::ConsumerLayers>(verifier, VT_PREFERRED_LAYERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_IGNORE_DTX, 1) &&
           verifier.EndTable();
  }
};

struct ConsumeRequestBuilder {
  typedef ConsumeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_consumer_id(flatbuffers::Offset<flatbuffers::String> consumer_id) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMER_ID, consumer_id);
  }
  void add_producer_id(flatbuffers::Offset<flatbuffers::String> producer_id) {
    fbb_.AddOffset(ConsumeRequest::VT_PRODUCER_ID, producer_id);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_rtp_parameters(flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtp_parameters) {
    fbb_.AddOffset(ConsumeRequest::VT_RTP_PARAMETERS, rtp_parameters);
  }
  void add_type(FBS::RtpParameters::Type type) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_consumable_rtp_encodings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumable_rtp_encodings) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMABLE_RTP_ENCODINGS, consumable_rtp_encodings);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_preferred_layers(const FBS::Consumer::ConsumerLayers *preferred_layers) {
    fbb_.AddStruct(ConsumeRequest::VT_PREFERRED_LAYERS, preferred_layers);
  }
  void add_ignore_dtx(bool ignore_dtx) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_IGNORE_DTX, static_cast<uint8_t>(ignore_dtx), 0);
  }
  explicit ConsumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsumeRequest>(end);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMER_ID);
    fbb_.Required(o, ConsumeRequest::VT_PRODUCER_ID);
    fbb_.Required(o, ConsumeRequest::VT_RTP_PARAMETERS);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMABLE_RTP_ENCODINGS);
    return o;
  }
};

inline flatbuffers::Offset<ConsumeRequest> CreateConsumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> consumer_id = 0,
    flatbuffers::Offset<flatbuffers::String> producer_id = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind_AUDIO,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtp_parameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumable_rtp_encodings = 0,
    bool paused = false,
    const FBS::Consumer::ConsumerLayers *preferred_layers = nullptr,
    bool ignore_dtx = false) {
  ConsumeRequestBuilder builder_(_fbb);
  builder_.add_preferred_layers(preferred_layers);
  builder_.add_consumable_rtp_encodings(consumable_rtp_encodings);
  builder_.add_rtp_parameters(rtp_parameters);
  builder_.add_producer_id(producer_id);
  builder_.add_consumer_id(consumer_id);
  builder_.add_ignore_dtx(ignore_dtx);
  builder_.add_paused(paused);
  builder_.add_type(type);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsumeRequest> CreateConsumeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *consumer_id = nullptr,
    const char *producer_id = nullptr,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind_AUDIO,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtp_parameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type_NONE,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumable_rtp_encodings = nullptr,
    bool paused = false,
    const FBS::Consumer::ConsumerLayers *preferred_layers = nullptr,
    bool ignore_dtx = false) {
  auto consumer_id__ = consumer_id ? _fbb.CreateString(consumer_id) : 0;
  auto producer_id__ = producer_id ? _fbb.CreateString(producer_id) : 0;
  auto consumable_rtp_encodings__ = consumable_rtp_encodings ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*consumable_rtp_encodings) : 0;
  return FBS::Transport::CreateConsumeRequest(
      _fbb,
      consumer_id__,
      producer_id__,
      kind,
      rtp_parameters,
      type,
      consumable_rtp_encodings__,
      paused,
      preferred_layers,
      ignore_dtx);
}

struct ConsumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsumeResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSED = 4,
    VT_PRODUCER_PAUSED = 6,
    VT_SCORE = 8,
    VT_PREFERRED_LAYERS = 10
  };
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool producer_paused() const {
    return GetField<uint8_t>(VT_PRODUCER_PAUSED, 0) != 0;
  }
  uint8_t score() const {
    return GetField<uint8_t>(VT_SCORE, 0);
  }
  const FBS::Consumer::ConsumerLayers *preferred_layers() const {
    return GetStruct<const FBS::Consumer::ConsumerLayers *>(VT_PREFERRED_LAYERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCER_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SCORE, 1) &&
           VerifyField<FBS::Consumer::ConsumerLayers>(verifier, VT_PREFERRED_LAYERS, 1) &&
           verifier.EndTable();
  }
};

struct ConsumeResponseBuilder {
  typedef ConsumeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_producer_paused(bool producer_paused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PRODUCER_PAUSED, static_cast<uint8_t>(producer_paused), 0);
  }
  void add_score(uint8_t score) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_SCORE, score, 0);
  }
  void add_preferred_layers(const FBS::Consumer::ConsumerLayers *preferred_layers) {
    fbb_.AddStruct(ConsumeResponse::VT_PREFERRED_LAYERS, preferred_layers);
  }
  explicit ConsumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConsumeResponse> CreateConsumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool paused = false,
    bool producer_paused = false,
    uint8_t score = 0,
    const FBS::Consumer::ConsumerLayers *preferred_layers = nullptr) {
  ConsumeResponseBuilder builder_(_fbb);
  builder_.add_preferred_layers(preferred_layers);
  builder_.add_score(score);
  builder_.add_producer_paused(producer_paused);
  builder_.add_paused(paused);
  return builder_.Finish();
}

inline const flatbuffers::TypeTable *ConsumeRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UCHAR, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable,
    FBS::RtpParameters::RtpParametersTypeTable,
    FBS::RtpParameters::TypeTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "consumer_id",
    "producer_id",
    "kind",
    "rtp_parameters",
    "type",
    "consumable_rtp_encodings",
    "paused",
    "preferred_layers",
    "ignore_dtx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConsumeResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "paused",
    "producer_paused",
    "score",
    "preferred_layers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const FBS::Transport::ConsumeRequest *GetConsumeRequest(const void *buf) {
  return flatbuffers::GetRoot<FBS::Transport::ConsumeRequest>(buf);
}

inline const FBS::Transport::ConsumeRequest *GetSizePrefixedConsumeRequest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FBS::Transport::ConsumeRequest>(buf);
}

inline bool VerifyConsumeRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FBS::Transport::ConsumeRequest>(nullptr);
}

inline bool VerifySizePrefixedConsumeRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FBS::Transport::ConsumeRequest>(nullptr);
}

inline void FinishConsumeRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::Transport::ConsumeRequest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedConsumeRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FBS::Transport::ConsumeRequest> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Transport
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
