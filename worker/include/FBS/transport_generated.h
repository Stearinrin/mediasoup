// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
#define FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"
#include "consumer_generated.h"
#include "rtpParameters_generated.h"
#include "sctpParameters_generated.h"

namespace FBS {
namespace Transport {

struct TransportListenIp;
struct TransportListenIpBuilder;

struct ConsumeRequest;
struct ConsumeRequestBuilder;

struct ConsumeResponse;
struct ConsumeResponseBuilder;

struct ProduceRequest;
struct ProduceRequestBuilder;

struct ProduceResponse;
struct ProduceResponseBuilder;

struct ProduceDataRequest;
struct ProduceDataRequestBuilder;

struct ConsumeDataRequest;
struct ConsumeDataRequestBuilder;

struct RtpListener;
struct RtpListenerBuilder;

struct SctpListener;
struct SctpListenerBuilder;

struct DumpResponse;
struct DumpResponseBuilder;

struct BaseTransportDump;
struct BaseTransportDumpBuilder;

struct IceParameters;
struct IceParametersBuilder;

struct IceCandidate;
struct IceCandidateBuilder;

struct Tuple;
struct TupleBuilder;

struct Fingerprint;
struct FingerprintBuilder;

struct DtlsParameters;
struct DtlsParametersBuilder;

struct WebRtcTransportDump;
struct WebRtcTransportDumpBuilder;

struct SrtpParameters;
struct SrtpParametersBuilder;

struct PlainTransportDump;
struct PlainTransportDumpBuilder;

struct DirectTransportDump;
struct DirectTransportDumpBuilder;

struct PipeTransportDump;
struct PipeTransportDumpBuilder;

struct BaseTransportOptions;
struct BaseTransportOptionsBuilder;

struct SetMaxIncomingBitrateRequest;
struct SetMaxIncomingBitrateRequestBuilder;

struct SetMaxOutgoingBitrateRequest;
struct SetMaxOutgoingBitrateRequestBuilder;

struct EnableTraceEventRequest;
struct EnableTraceEventRequestBuilder;

struct CloseProducerRequest;
struct CloseProducerRequestBuilder;

struct CloseConsumerRequest;
struct CloseConsumerRequestBuilder;

struct CloseDataProducerRequest;
struct CloseDataProducerRequestBuilder;

struct CloseDataConsumerRequest;
struct CloseDataConsumerRequestBuilder;

inline const flatbuffers::TypeTable *TransportListenIpTypeTable();

inline const flatbuffers::TypeTable *ConsumeRequestTypeTable();

inline const flatbuffers::TypeTable *ConsumeResponseTypeTable();

inline const flatbuffers::TypeTable *ProduceRequestTypeTable();

inline const flatbuffers::TypeTable *ProduceResponseTypeTable();

inline const flatbuffers::TypeTable *ProduceDataRequestTypeTable();

inline const flatbuffers::TypeTable *ConsumeDataRequestTypeTable();

inline const flatbuffers::TypeTable *RtpListenerTypeTable();

inline const flatbuffers::TypeTable *SctpListenerTypeTable();

inline const flatbuffers::TypeTable *DumpResponseTypeTable();

inline const flatbuffers::TypeTable *BaseTransportDumpTypeTable();

inline const flatbuffers::TypeTable *IceParametersTypeTable();

inline const flatbuffers::TypeTable *IceCandidateTypeTable();

inline const flatbuffers::TypeTable *TupleTypeTable();

inline const flatbuffers::TypeTable *FingerprintTypeTable();

inline const flatbuffers::TypeTable *DtlsParametersTypeTable();

inline const flatbuffers::TypeTable *WebRtcTransportDumpTypeTable();

inline const flatbuffers::TypeTable *SrtpParametersTypeTable();

inline const flatbuffers::TypeTable *PlainTransportDumpTypeTable();

inline const flatbuffers::TypeTable *DirectTransportDumpTypeTable();

inline const flatbuffers::TypeTable *PipeTransportDumpTypeTable();

inline const flatbuffers::TypeTable *BaseTransportOptionsTypeTable();

inline const flatbuffers::TypeTable *SetMaxIncomingBitrateRequestTypeTable();

inline const flatbuffers::TypeTable *SetMaxOutgoingBitrateRequestTypeTable();

inline const flatbuffers::TypeTable *EnableTraceEventRequestTypeTable();

inline const flatbuffers::TypeTable *CloseProducerRequestTypeTable();

inline const flatbuffers::TypeTable *CloseConsumerRequestTypeTable();

inline const flatbuffers::TypeTable *CloseDataProducerRequestTypeTable();

inline const flatbuffers::TypeTable *CloseDataConsumerRequestTypeTable();

enum class TransportProtocol : uint8_t {
  UDP = 1,
  TCP = 2,
  MIN = UDP,
  MAX = TCP
};

inline const TransportProtocol (&EnumValuesTransportProtocol())[2] {
  static const TransportProtocol values[] = {
    TransportProtocol::UDP,
    TransportProtocol::TCP
  };
  return values;
}

inline const char * const *EnumNamesTransportProtocol() {
  static const char * const names[3] = {
    "UDP",
    "TCP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTransportProtocol(TransportProtocol e) {
  if (flatbuffers::IsOutRange(e, TransportProtocol::UDP, TransportProtocol::TCP)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TransportProtocol::UDP);
  return EnumNamesTransportProtocol()[index];
}

enum class TransportDumpData : uint8_t {
  NONE = 0,
  BaseTransportDump = 1,
  DirectTransportDump = 2,
  PipeTransportDump = 3,
  PlainTransportDump = 4,
  WebRtcTransportDump = 5,
  MIN = NONE,
  MAX = WebRtcTransportDump
};

inline const TransportDumpData (&EnumValuesTransportDumpData())[6] {
  static const TransportDumpData values[] = {
    TransportDumpData::NONE,
    TransportDumpData::BaseTransportDump,
    TransportDumpData::DirectTransportDump,
    TransportDumpData::PipeTransportDump,
    TransportDumpData::PlainTransportDump,
    TransportDumpData::WebRtcTransportDump
  };
  return values;
}

inline const char * const *EnumNamesTransportDumpData() {
  static const char * const names[7] = {
    "NONE",
    "BaseTransportDump",
    "DirectTransportDump",
    "PipeTransportDump",
    "PlainTransportDump",
    "WebRtcTransportDump",
    nullptr
  };
  return names;
}

inline const char *EnumNameTransportDumpData(TransportDumpData e) {
  if (flatbuffers::IsOutRange(e, TransportDumpData::NONE, TransportDumpData::WebRtcTransportDump)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTransportDumpData()[index];
}

template<typename T> struct TransportDumpDataTraits {
  static const TransportDumpData enum_value = TransportDumpData::NONE;
};

template<> struct TransportDumpDataTraits<FBS::Transport::BaseTransportDump> {
  static const TransportDumpData enum_value = TransportDumpData::BaseTransportDump;
};

template<> struct TransportDumpDataTraits<FBS::Transport::DirectTransportDump> {
  static const TransportDumpData enum_value = TransportDumpData::DirectTransportDump;
};

template<> struct TransportDumpDataTraits<FBS::Transport::PipeTransportDump> {
  static const TransportDumpData enum_value = TransportDumpData::PipeTransportDump;
};

template<> struct TransportDumpDataTraits<FBS::Transport::PlainTransportDump> {
  static const TransportDumpData enum_value = TransportDumpData::PlainTransportDump;
};

template<> struct TransportDumpDataTraits<FBS::Transport::WebRtcTransportDump> {
  static const TransportDumpData enum_value = TransportDumpData::WebRtcTransportDump;
};

bool VerifyTransportDumpData(flatbuffers::Verifier &verifier, const void *obj, TransportDumpData type);
bool VerifyTransportDumpDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<TransportDumpData> *types);

struct TransportListenIp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransportListenIpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TransportListenIpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IP = 4,
    VT_ANNOUNCEDIP = 6
  };
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  const flatbuffers::String *announcedIp() const {
    return GetPointer<const flatbuffers::String *>(VT_ANNOUNCEDIP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyOffset(verifier, VT_ANNOUNCEDIP) &&
           verifier.VerifyString(announcedIp()) &&
           verifier.EndTable();
  }
};

struct TransportListenIpBuilder {
  typedef TransportListenIp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(TransportListenIp::VT_IP, ip);
  }
  void add_announcedIp(flatbuffers::Offset<flatbuffers::String> announcedIp) {
    fbb_.AddOffset(TransportListenIp::VT_ANNOUNCEDIP, announcedIp);
  }
  explicit TransportListenIpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TransportListenIp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransportListenIp>(end);
    fbb_.Required(o, TransportListenIp::VT_IP);
    return o;
  }
};

inline flatbuffers::Offset<TransportListenIp> CreateTransportListenIp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    flatbuffers::Offset<flatbuffers::String> announcedIp = 0) {
  TransportListenIpBuilder builder_(_fbb);
  builder_.add_announcedIp(announcedIp);
  builder_.add_ip(ip);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransportListenIp> CreateTransportListenIpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ip = nullptr,
    const char *announcedIp = nullptr) {
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  auto announcedIp__ = announcedIp ? _fbb.CreateString(announcedIp) : 0;
  return FBS::Transport::CreateTransportListenIp(
      _fbb,
      ip__,
      announcedIp__);
}

struct ConsumeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsumeRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSUMERID = 4,
    VT_PRODUCERID = 6,
    VT_KIND = 8,
    VT_RTPPARAMETERS = 10,
    VT_TYPE = 12,
    VT_CONSUMABLERTPENCODINGS = 14,
    VT_PAUSED = 16,
    VT_PREFERREDLAYERS = 18,
    VT_IGNOREDTX = 20
  };
  const flatbuffers::String *consumerId() const {
    return GetPointer<const flatbuffers::String *>(VT_CONSUMERID);
  }
  const flatbuffers::String *producerId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCERID);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const FBS::RtpParameters::RtpParameters *rtpParameters() const {
    return GetPointer<const FBS::RtpParameters::RtpParameters *>(VT_RTPPARAMETERS);
  }
  FBS::RtpParameters::Type type() const {
    return static_cast<FBS::RtpParameters::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumableRtpEncodings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *>(VT_CONSUMABLERTPENCODINGS);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  const FBS::Consumer::ConsumerLayers *preferredLayers() const {
    return GetPointer<const FBS::Consumer::ConsumerLayers *>(VT_PREFERREDLAYERS);
  }
  bool ignoreDtx() const {
    return GetField<uint8_t>(VT_IGNOREDTX, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERID) &&
           verifier.VerifyString(consumerId()) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_RTPPARAMETERS) &&
           verifier.VerifyTable(rtpParameters()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_CONSUMABLERTPENCODINGS) &&
           verifier.VerifyVector(consumableRtpEncodings()) &&
           verifier.VerifyVectorOfTables(consumableRtpEncodings()) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyOffset(verifier, VT_PREFERREDLAYERS) &&
           verifier.VerifyTable(preferredLayers()) &&
           VerifyField<uint8_t>(verifier, VT_IGNOREDTX, 1) &&
           verifier.EndTable();
  }
};

struct ConsumeRequestBuilder {
  typedef ConsumeRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_consumerId(flatbuffers::Offset<flatbuffers::String> consumerId) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMERID, consumerId);
  }
  void add_producerId(flatbuffers::Offset<flatbuffers::String> producerId) {
    fbb_.AddOffset(ConsumeRequest::VT_PRODUCERID, producerId);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_rtpParameters(flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters) {
    fbb_.AddOffset(ConsumeRequest::VT_RTPPARAMETERS, rtpParameters);
  }
  void add_type(FBS::RtpParameters::Type type) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_consumableRtpEncodings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumableRtpEncodings) {
    fbb_.AddOffset(ConsumeRequest::VT_CONSUMABLERTPENCODINGS, consumableRtpEncodings);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_preferredLayers(flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers) {
    fbb_.AddOffset(ConsumeRequest::VT_PREFERREDLAYERS, preferredLayers);
  }
  void add_ignoreDtx(bool ignoreDtx) {
    fbb_.AddElement<uint8_t>(ConsumeRequest::VT_IGNOREDTX, static_cast<uint8_t>(ignoreDtx), 0);
  }
  explicit ConsumeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsumeRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsumeRequest>(end);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMERID);
    fbb_.Required(o, ConsumeRequest::VT_PRODUCERID);
    fbb_.Required(o, ConsumeRequest::VT_RTPPARAMETERS);
    fbb_.Required(o, ConsumeRequest::VT_CONSUMABLERTPENCODINGS);
    return o;
  }
};

inline flatbuffers::Offset<ConsumeRequest> CreateConsumeRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> consumerId = 0,
    flatbuffers::Offset<flatbuffers::String> producerId = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>> consumableRtpEncodings = 0,
    bool paused = false,
    flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0,
    bool ignoreDtx = false) {
  ConsumeRequestBuilder builder_(_fbb);
  builder_.add_preferredLayers(preferredLayers);
  builder_.add_consumableRtpEncodings(consumableRtpEncodings);
  builder_.add_rtpParameters(rtpParameters);
  builder_.add_producerId(producerId);
  builder_.add_consumerId(consumerId);
  builder_.add_ignoreDtx(ignoreDtx);
  builder_.add_paused(paused);
  builder_.add_type(type);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsumeRequest> CreateConsumeRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *consumerId = nullptr,
    const char *producerId = nullptr,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE,
    const std::vector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>> *consumableRtpEncodings = nullptr,
    bool paused = false,
    flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0,
    bool ignoreDtx = false) {
  auto consumerId__ = consumerId ? _fbb.CreateString(consumerId) : 0;
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  auto consumableRtpEncodings__ = consumableRtpEncodings ? _fbb.CreateVector<flatbuffers::Offset<FBS::RtpParameters::RtpEncodingParameters>>(*consumableRtpEncodings) : 0;
  return FBS::Transport::CreateConsumeRequest(
      _fbb,
      consumerId__,
      producerId__,
      kind,
      rtpParameters,
      type,
      consumableRtpEncodings__,
      paused,
      preferredLayers,
      ignoreDtx);
}

struct ConsumeResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsumeResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAUSED = 4,
    VT_PRODUCERPAUSED = 6,
    VT_SCORE = 8,
    VT_PREFERREDLAYERS = 10
  };
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool producerPaused() const {
    return GetField<uint8_t>(VT_PRODUCERPAUSED, 0) != 0;
  }
  const FBS::Consumer::ConsumerScore *score() const {
    return GetPointer<const FBS::Consumer::ConsumerScore *>(VT_SCORE);
  }
  const FBS::Consumer::ConsumerLayers *preferredLayers() const {
    return GetPointer<const FBS::Consumer::ConsumerLayers *>(VT_PREFERREDLAYERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_PRODUCERPAUSED, 1) &&
           VerifyOffset(verifier, VT_SCORE) &&
           verifier.VerifyTable(score()) &&
           VerifyOffset(verifier, VT_PREFERREDLAYERS) &&
           verifier.VerifyTable(preferredLayers()) &&
           verifier.EndTable();
  }
};

struct ConsumeResponseBuilder {
  typedef ConsumeResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_producerPaused(bool producerPaused) {
    fbb_.AddElement<uint8_t>(ConsumeResponse::VT_PRODUCERPAUSED, static_cast<uint8_t>(producerPaused), 0);
  }
  void add_score(flatbuffers::Offset<FBS::Consumer::ConsumerScore> score) {
    fbb_.AddOffset(ConsumeResponse::VT_SCORE, score);
  }
  void add_preferredLayers(flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers) {
    fbb_.AddOffset(ConsumeResponse::VT_PREFERREDLAYERS, preferredLayers);
  }
  explicit ConsumeResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsumeResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsumeResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConsumeResponse> CreateConsumeResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool paused = false,
    bool producerPaused = false,
    flatbuffers::Offset<FBS::Consumer::ConsumerScore> score = 0,
    flatbuffers::Offset<FBS::Consumer::ConsumerLayers> preferredLayers = 0) {
  ConsumeResponseBuilder builder_(_fbb);
  builder_.add_preferredLayers(preferredLayers);
  builder_.add_score(score);
  builder_.add_producerPaused(producerPaused);
  builder_.add_paused(paused);
  return builder_.Finish();
}

struct ProduceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProduceRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCERID = 4,
    VT_KIND = 6,
    VT_RTPPARAMETERS = 8,
    VT_RTPMAPPING = 10,
    VT_KEYFRAMEREQUESTDELAY = 12,
    VT_PAUSED = 14
  };
  const flatbuffers::String *producerId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCERID);
  }
  FBS::RtpParameters::MediaKind kind() const {
    return static_cast<FBS::RtpParameters::MediaKind>(GetField<uint8_t>(VT_KIND, 0));
  }
  const FBS::RtpParameters::RtpParameters *rtpParameters() const {
    return GetPointer<const FBS::RtpParameters::RtpParameters *>(VT_RTPPARAMETERS);
  }
  const FBS::RtpParameters::RtpMapping *rtpMapping() const {
    return GetPointer<const FBS::RtpParameters::RtpMapping *>(VT_RTPMAPPING);
  }
  uint16_t keyFrameRequestDelay() const {
    return GetField<uint16_t>(VT_KEYFRAMEREQUESTDELAY, 0);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           VerifyField<uint8_t>(verifier, VT_KIND, 1) &&
           VerifyOffsetRequired(verifier, VT_RTPPARAMETERS) &&
           verifier.VerifyTable(rtpParameters()) &&
           VerifyOffsetRequired(verifier, VT_RTPMAPPING) &&
           verifier.VerifyTable(rtpMapping()) &&
           VerifyField<uint16_t>(verifier, VT_KEYFRAMEREQUESTDELAY, 2) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           verifier.EndTable();
  }
};

struct ProduceRequestBuilder {
  typedef ProduceRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_producerId(flatbuffers::Offset<flatbuffers::String> producerId) {
    fbb_.AddOffset(ProduceRequest::VT_PRODUCERID, producerId);
  }
  void add_kind(FBS::RtpParameters::MediaKind kind) {
    fbb_.AddElement<uint8_t>(ProduceRequest::VT_KIND, static_cast<uint8_t>(kind), 0);
  }
  void add_rtpParameters(flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters) {
    fbb_.AddOffset(ProduceRequest::VT_RTPPARAMETERS, rtpParameters);
  }
  void add_rtpMapping(flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping) {
    fbb_.AddOffset(ProduceRequest::VT_RTPMAPPING, rtpMapping);
  }
  void add_keyFrameRequestDelay(uint16_t keyFrameRequestDelay) {
    fbb_.AddElement<uint16_t>(ProduceRequest::VT_KEYFRAMEREQUESTDELAY, keyFrameRequestDelay, 0);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(ProduceRequest::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  explicit ProduceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProduceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProduceRequest>(end);
    fbb_.Required(o, ProduceRequest::VT_PRODUCERID);
    fbb_.Required(o, ProduceRequest::VT_RTPPARAMETERS);
    fbb_.Required(o, ProduceRequest::VT_RTPMAPPING);
    return o;
  }
};

inline flatbuffers::Offset<ProduceRequest> CreateProduceRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> producerId = 0,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping = 0,
    uint16_t keyFrameRequestDelay = 0,
    bool paused = false) {
  ProduceRequestBuilder builder_(_fbb);
  builder_.add_rtpMapping(rtpMapping);
  builder_.add_rtpParameters(rtpParameters);
  builder_.add_producerId(producerId);
  builder_.add_keyFrameRequestDelay(keyFrameRequestDelay);
  builder_.add_paused(paused);
  builder_.add_kind(kind);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProduceRequest> CreateProduceRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *producerId = nullptr,
    FBS::RtpParameters::MediaKind kind = FBS::RtpParameters::MediaKind::ALL,
    flatbuffers::Offset<FBS::RtpParameters::RtpParameters> rtpParameters = 0,
    flatbuffers::Offset<FBS::RtpParameters::RtpMapping> rtpMapping = 0,
    uint16_t keyFrameRequestDelay = 0,
    bool paused = false) {
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  return FBS::Transport::CreateProduceRequest(
      _fbb,
      producerId__,
      kind,
      rtpParameters,
      rtpMapping,
      keyFrameRequestDelay,
      paused);
}

struct ProduceResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProduceResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  FBS::RtpParameters::Type type() const {
    return static_cast<FBS::RtpParameters::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ProduceResponseBuilder {
  typedef ProduceResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FBS::RtpParameters::Type type) {
    fbb_.AddElement<uint8_t>(ProduceResponse::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit ProduceResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProduceResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProduceResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProduceResponse> CreateProduceResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    FBS::RtpParameters::Type type = FBS::RtpParameters::Type::NONE) {
  ProduceResponseBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ProduceDataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProduceDataRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProduceDataRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAPRODUCERID = 4,
    VT_TYPE = 6,
    VT_SCTPSTREAMPARAMETERS = 8,
    VT_LABEL = 10,
    VT_PROTOCOL = 12
  };
  const flatbuffers::String *dataProducerId() const {
    return GetPointer<const flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const FBS::SctpParameters::SctpStreamParameters *sctpStreamParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpStreamParameters *>(VT_SCTPSTREAMPARAMETERS);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_SCTPSTREAMPARAMETERS) &&
           verifier.VerifyTable(sctpStreamParameters()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           verifier.EndTable();
  }
};

struct ProduceDataRequestBuilder {
  typedef ProduceDataRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataProducerId(flatbuffers::Offset<flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(ProduceDataRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ProduceDataRequest::VT_TYPE, type);
  }
  void add_sctpStreamParameters(flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters) {
    fbb_.AddOffset(ProduceDataRequest::VT_SCTPSTREAMPARAMETERS, sctpStreamParameters);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(ProduceDataRequest::VT_LABEL, label);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ProduceDataRequest::VT_PROTOCOL, protocol);
  }
  explicit ProduceDataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProduceDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProduceDataRequest>(end);
    fbb_.Required(o, ProduceDataRequest::VT_DATAPRODUCERID);
    fbb_.Required(o, ProduceDataRequest::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<ProduceDataRequest> CreateProduceDataRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dataProducerId = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0) {
  ProduceDataRequestBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  builder_.add_sctpStreamParameters(sctpStreamParameters);
  builder_.add_type(type);
  builder_.add_dataProducerId(dataProducerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProduceDataRequest> CreateProduceDataRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataProducerId = nullptr,
    const char *type = nullptr,
    flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    const char *label = nullptr,
    const char *protocol = nullptr) {
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  return FBS::Transport::CreateProduceDataRequest(
      _fbb,
      dataProducerId__,
      type__,
      sctpStreamParameters,
      label__,
      protocol__);
}

struct ConsumeDataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConsumeDataRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConsumeDataRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATACONSUMERID = 4,
    VT_DATAPRODUCERID = 6,
    VT_TYPE = 8,
    VT_SCTPSTREAMPARAMETERS = 10,
    VT_LABEL = 12,
    VT_PROTOCOL = 14
  };
  const flatbuffers::String *dataConsumerId() const {
    return GetPointer<const flatbuffers::String *>(VT_DATACONSUMERID);
  }
  const flatbuffers::String *dataProducerId() const {
    return GetPointer<const flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const FBS::SctpParameters::SctpStreamParameters *sctpStreamParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpStreamParameters *>(VT_SCTPSTREAMPARAMETERS);
  }
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERID) &&
           verifier.VerifyString(dataConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_SCTPSTREAMPARAMETERS) &&
           verifier.VerifyTable(sctpStreamParameters()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           verifier.EndTable();
  }
};

struct ConsumeDataRequestBuilder {
  typedef ConsumeDataRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataConsumerId(flatbuffers::Offset<flatbuffers::String> dataConsumerId) {
    fbb_.AddOffset(ConsumeDataRequest::VT_DATACONSUMERID, dataConsumerId);
  }
  void add_dataProducerId(flatbuffers::Offset<flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(ConsumeDataRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ConsumeDataRequest::VT_TYPE, type);
  }
  void add_sctpStreamParameters(flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters) {
    fbb_.AddOffset(ConsumeDataRequest::VT_SCTPSTREAMPARAMETERS, sctpStreamParameters);
  }
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(ConsumeDataRequest::VT_LABEL, label);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ConsumeDataRequest::VT_PROTOCOL, protocol);
  }
  explicit ConsumeDataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConsumeDataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConsumeDataRequest>(end);
    fbb_.Required(o, ConsumeDataRequest::VT_DATACONSUMERID);
    fbb_.Required(o, ConsumeDataRequest::VT_DATAPRODUCERID);
    fbb_.Required(o, ConsumeDataRequest::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<ConsumeDataRequest> CreateConsumeDataRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dataConsumerId = 0,
    flatbuffers::Offset<flatbuffers::String> dataProducerId = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0) {
  ConsumeDataRequestBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  builder_.add_sctpStreamParameters(sctpStreamParameters);
  builder_.add_type(type);
  builder_.add_dataProducerId(dataProducerId);
  builder_.add_dataConsumerId(dataConsumerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsumeDataRequest> CreateConsumeDataRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataConsumerId = nullptr,
    const char *dataProducerId = nullptr,
    const char *type = nullptr,
    flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    const char *label = nullptr,
    const char *protocol = nullptr) {
  auto dataConsumerId__ = dataConsumerId ? _fbb.CreateString(dataConsumerId) : 0;
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  return FBS::Transport::CreateConsumeDataRequest(
      _fbb,
      dataConsumerId__,
      dataProducerId__,
      type__,
      sctpStreamParameters,
      label__,
      protocol__);
}

struct RtpListener FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RtpListenerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RtpListenerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSRCTABLE = 4,
    VT_MIDTABLE = 6,
    VT_RIDTABLE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *ssrcTable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_SSRCTABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>> *midTable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>> *>(VT_MIDTABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>> *ridTable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>> *>(VT_RIDTABLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SSRCTABLE) &&
           verifier.VerifyVector(ssrcTable()) &&
           verifier.VerifyVectorOfTables(ssrcTable()) &&
           VerifyOffsetRequired(verifier, VT_MIDTABLE) &&
           verifier.VerifyVector(midTable()) &&
           verifier.VerifyVectorOfTables(midTable()) &&
           VerifyOffsetRequired(verifier, VT_RIDTABLE) &&
           verifier.VerifyVector(ridTable()) &&
           verifier.VerifyVectorOfTables(ridTable()) &&
           verifier.EndTable();
  }
};

struct RtpListenerBuilder {
  typedef RtpListener Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssrcTable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> ssrcTable) {
    fbb_.AddOffset(RtpListener::VT_SSRCTABLE, ssrcTable);
  }
  void add_midTable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>>> midTable) {
    fbb_.AddOffset(RtpListener::VT_MIDTABLE, midTable);
  }
  void add_ridTable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>>> ridTable) {
    fbb_.AddOffset(RtpListener::VT_RIDTABLE, ridTable);
  }
  explicit RtpListenerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RtpListener> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RtpListener>(end);
    fbb_.Required(o, RtpListener::VT_SSRCTABLE);
    fbb_.Required(o, RtpListener::VT_MIDTABLE);
    fbb_.Required(o, RtpListener::VT_RIDTABLE);
    return o;
  }
};

inline flatbuffers::Offset<RtpListener> CreateRtpListener(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> ssrcTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>>> midTable = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringString>>> ridTable = 0) {
  RtpListenerBuilder builder_(_fbb);
  builder_.add_ridTable(ridTable);
  builder_.add_midTable(midTable);
  builder_.add_ssrcTable(ssrcTable);
  return builder_.Finish();
}

inline flatbuffers::Offset<RtpListener> CreateRtpListenerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::Common::Uint32String>> *ssrcTable = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Common::StringString>> *midTable = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Common::StringString>> *ridTable = nullptr) {
  auto ssrcTable__ = ssrcTable ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::Uint32String>>(*ssrcTable) : 0;
  auto midTable__ = midTable ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::StringString>>(*midTable) : 0;
  auto ridTable__ = ridTable ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::StringString>>(*ridTable) : 0;
  return FBS::Transport::CreateRtpListener(
      _fbb,
      ssrcTable__,
      midTable__,
      ridTable__);
}

struct SctpListener FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SctpListenerBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SctpListenerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAMIDTABLE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint16String>> *streamIdTable() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint16String>> *>(VT_STREAMIDTABLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_STREAMIDTABLE) &&
           verifier.VerifyVector(streamIdTable()) &&
           verifier.VerifyVectorOfTables(streamIdTable()) &&
           verifier.EndTable();
  }
};

struct SctpListenerBuilder {
  typedef SctpListener Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_streamIdTable(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint16String>>> streamIdTable) {
    fbb_.AddOffset(SctpListener::VT_STREAMIDTABLE, streamIdTable);
  }
  explicit SctpListenerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SctpListener> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SctpListener>(end);
    fbb_.Required(o, SctpListener::VT_STREAMIDTABLE);
    return o;
  }
};

inline flatbuffers::Offset<SctpListener> CreateSctpListener(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint16String>>> streamIdTable = 0) {
  SctpListenerBuilder builder_(_fbb);
  builder_.add_streamIdTable(streamIdTable);
  return builder_.Finish();
}

inline flatbuffers::Offset<SctpListener> CreateSctpListenerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::Common::Uint16String>> *streamIdTable = nullptr) {
  auto streamIdTable__ = streamIdTable ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::Uint16String>>(*streamIdTable) : 0;
  return FBS::Transport::CreateSctpListener(
      _fbb,
      streamIdTable__);
}

struct DumpResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DumpResponseBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  FBS::Transport::TransportDumpData data_type() const {
    return static_cast<FBS::Transport::TransportDumpData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const FBS::Transport::BaseTransportDump *data_as_BaseTransportDump() const {
    return data_type() == FBS::Transport::TransportDumpData::BaseTransportDump ? static_cast<const FBS::Transport::BaseTransportDump *>(data()) : nullptr;
  }
  const FBS::Transport::DirectTransportDump *data_as_DirectTransportDump() const {
    return data_type() == FBS::Transport::TransportDumpData::DirectTransportDump ? static_cast<const FBS::Transport::DirectTransportDump *>(data()) : nullptr;
  }
  const FBS::Transport::PipeTransportDump *data_as_PipeTransportDump() const {
    return data_type() == FBS::Transport::TransportDumpData::PipeTransportDump ? static_cast<const FBS::Transport::PipeTransportDump *>(data()) : nullptr;
  }
  const FBS::Transport::PlainTransportDump *data_as_PlainTransportDump() const {
    return data_type() == FBS::Transport::TransportDumpData::PlainTransportDump ? static_cast<const FBS::Transport::PlainTransportDump *>(data()) : nullptr;
  }
  const FBS::Transport::WebRtcTransportDump *data_as_WebRtcTransportDump() const {
    return data_type() == FBS::Transport::TransportDumpData::WebRtcTransportDump ? static_cast<const FBS::Transport::WebRtcTransportDump *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyTransportDumpData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const FBS::Transport::BaseTransportDump *DumpResponse::data_as<FBS::Transport::BaseTransportDump>() const {
  return data_as_BaseTransportDump();
}

template<> inline const FBS::Transport::DirectTransportDump *DumpResponse::data_as<FBS::Transport::DirectTransportDump>() const {
  return data_as_DirectTransportDump();
}

template<> inline const FBS::Transport::PipeTransportDump *DumpResponse::data_as<FBS::Transport::PipeTransportDump>() const {
  return data_as_PipeTransportDump();
}

template<> inline const FBS::Transport::PlainTransportDump *DumpResponse::data_as<FBS::Transport::PlainTransportDump>() const {
  return data_as_PlainTransportDump();
}

template<> inline const FBS::Transport::WebRtcTransportDump *DumpResponse::data_as<FBS::Transport::WebRtcTransportDump>() const {
  return data_as_WebRtcTransportDump();
}

struct DumpResponseBuilder {
  typedef DumpResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(FBS::Transport::TransportDumpData data_type) {
    fbb_.AddElement<uint8_t>(DumpResponse::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(DumpResponse::VT_DATA, data);
  }
  explicit DumpResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DumpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DumpResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<DumpResponse> CreateDumpResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    FBS::Transport::TransportDumpData data_type = FBS::Transport::TransportDumpData::NONE,
    flatbuffers::Offset<void> data = 0) {
  DumpResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct BaseTransportDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseTransportDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BaseTransportDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DIRECT = 6,
    VT_PRODUCERIDS = 8,
    VT_CONSUMERIDS = 10,
    VT_MAPSSRCCONSUMERID = 12,
    VT_MAPRTXSSRCCONSUMERID = 14,
    VT_DATAPRODUCERIDS = 16,
    VT_DATACONSUMERIDS = 18,
    VT_RECVRTPHEADEREXTENSIONS = 20,
    VT_RTPLISTENER = 22,
    VT_MAXMESSAGESIZE = 24,
    VT_SCTPPARAMETERS = 26,
    VT_SCTPSTATE = 28,
    VT_SCTPLISTENER = 30,
    VT_TRACEEVENTTYPES = 32
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool direct() const {
    return GetField<uint8_t>(VT_DIRECT, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *producerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PRODUCERIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *consumerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CONSUMERIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *mapSsrcConsumerId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_MAPSSRCCONSUMERID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *mapRtxSsrcConsumerId() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>> *>(VT_MAPRTXSSRCCONSUMERID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dataProducerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATAPRODUCERIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dataConsumerIds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATACONSUMERIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringUint8>> *recvRtpHeaderExtensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringUint8>> *>(VT_RECVRTPHEADEREXTENSIONS);
  }
  const FBS::Transport::RtpListener *rtpListener() const {
    return GetPointer<const FBS::Transport::RtpListener *>(VT_RTPLISTENER);
  }
  uint32_t maxMessageSize() const {
    return GetField<uint32_t>(VT_MAXMESSAGESIZE, 0);
  }
  const FBS::SctpParameters::SctpParameters *sctpParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpParameters *>(VT_SCTPPARAMETERS);
  }
  const flatbuffers::String *sctpState() const {
    return GetPointer<const flatbuffers::String *>(VT_SCTPSTATE);
  }
  const FBS::Transport::SctpListener *sctpListener() const {
    return GetPointer<const FBS::Transport::SctpListener *>(VT_SCTPLISTENER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *traceEventTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TRACEEVENTTYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_DIRECT, 1) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERIDS) &&
           verifier.VerifyVector(producerIds()) &&
           verifier.VerifyVectorOfStrings(producerIds()) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERIDS) &&
           verifier.VerifyVector(consumerIds()) &&
           verifier.VerifyVectorOfStrings(consumerIds()) &&
           VerifyOffsetRequired(verifier, VT_MAPSSRCCONSUMERID) &&
           verifier.VerifyVector(mapSsrcConsumerId()) &&
           verifier.VerifyVectorOfTables(mapSsrcConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_MAPRTXSSRCCONSUMERID) &&
           verifier.VerifyVector(mapRtxSsrcConsumerId()) &&
           verifier.VerifyVectorOfTables(mapRtxSsrcConsumerId()) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERIDS) &&
           verifier.VerifyVector(dataProducerIds()) &&
           verifier.VerifyVectorOfStrings(dataProducerIds()) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERIDS) &&
           verifier.VerifyVector(dataConsumerIds()) &&
           verifier.VerifyVectorOfStrings(dataConsumerIds()) &&
           VerifyOffsetRequired(verifier, VT_RECVRTPHEADEREXTENSIONS) &&
           verifier.VerifyVector(recvRtpHeaderExtensions()) &&
           verifier.VerifyVectorOfTables(recvRtpHeaderExtensions()) &&
           VerifyOffsetRequired(verifier, VT_RTPLISTENER) &&
           verifier.VerifyTable(rtpListener()) &&
           VerifyField<uint32_t>(verifier, VT_MAXMESSAGESIZE, 4) &&
           VerifyOffset(verifier, VT_SCTPPARAMETERS) &&
           verifier.VerifyTable(sctpParameters()) &&
           VerifyOffset(verifier, VT_SCTPSTATE) &&
           verifier.VerifyString(sctpState()) &&
           VerifyOffset(verifier, VT_SCTPLISTENER) &&
           verifier.VerifyTable(sctpListener()) &&
           VerifyOffsetRequired(verifier, VT_TRACEEVENTTYPES) &&
           verifier.VerifyVector(traceEventTypes()) &&
           verifier.VerifyVectorOfStrings(traceEventTypes()) &&
           verifier.EndTable();
  }
};

struct BaseTransportDumpBuilder {
  typedef BaseTransportDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(BaseTransportDump::VT_ID, id);
  }
  void add_direct(bool direct) {
    fbb_.AddElement<uint8_t>(BaseTransportDump::VT_DIRECT, static_cast<uint8_t>(direct), 0);
  }
  void add_producerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> producerIds) {
    fbb_.AddOffset(BaseTransportDump::VT_PRODUCERIDS, producerIds);
  }
  void add_consumerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> consumerIds) {
    fbb_.AddOffset(BaseTransportDump::VT_CONSUMERIDS, consumerIds);
  }
  void add_mapSsrcConsumerId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> mapSsrcConsumerId) {
    fbb_.AddOffset(BaseTransportDump::VT_MAPSSRCCONSUMERID, mapSsrcConsumerId);
  }
  void add_mapRtxSsrcConsumerId(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> mapRtxSsrcConsumerId) {
    fbb_.AddOffset(BaseTransportDump::VT_MAPRTXSSRCCONSUMERID, mapRtxSsrcConsumerId);
  }
  void add_dataProducerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dataProducerIds) {
    fbb_.AddOffset(BaseTransportDump::VT_DATAPRODUCERIDS, dataProducerIds);
  }
  void add_dataConsumerIds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dataConsumerIds) {
    fbb_.AddOffset(BaseTransportDump::VT_DATACONSUMERIDS, dataConsumerIds);
  }
  void add_recvRtpHeaderExtensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringUint8>>> recvRtpHeaderExtensions) {
    fbb_.AddOffset(BaseTransportDump::VT_RECVRTPHEADEREXTENSIONS, recvRtpHeaderExtensions);
  }
  void add_rtpListener(flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener) {
    fbb_.AddOffset(BaseTransportDump::VT_RTPLISTENER, rtpListener);
  }
  void add_maxMessageSize(uint32_t maxMessageSize) {
    fbb_.AddElement<uint32_t>(BaseTransportDump::VT_MAXMESSAGESIZE, maxMessageSize, 0);
  }
  void add_sctpParameters(flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters) {
    fbb_.AddOffset(BaseTransportDump::VT_SCTPPARAMETERS, sctpParameters);
  }
  void add_sctpState(flatbuffers::Offset<flatbuffers::String> sctpState) {
    fbb_.AddOffset(BaseTransportDump::VT_SCTPSTATE, sctpState);
  }
  void add_sctpListener(flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener) {
    fbb_.AddOffset(BaseTransportDump::VT_SCTPLISTENER, sctpListener);
  }
  void add_traceEventTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> traceEventTypes) {
    fbb_.AddOffset(BaseTransportDump::VT_TRACEEVENTTYPES, traceEventTypes);
  }
  explicit BaseTransportDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BaseTransportDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseTransportDump>(end);
    fbb_.Required(o, BaseTransportDump::VT_ID);
    fbb_.Required(o, BaseTransportDump::VT_PRODUCERIDS);
    fbb_.Required(o, BaseTransportDump::VT_CONSUMERIDS);
    fbb_.Required(o, BaseTransportDump::VT_MAPSSRCCONSUMERID);
    fbb_.Required(o, BaseTransportDump::VT_MAPRTXSSRCCONSUMERID);
    fbb_.Required(o, BaseTransportDump::VT_DATAPRODUCERIDS);
    fbb_.Required(o, BaseTransportDump::VT_DATACONSUMERIDS);
    fbb_.Required(o, BaseTransportDump::VT_RECVRTPHEADEREXTENSIONS);
    fbb_.Required(o, BaseTransportDump::VT_RTPLISTENER);
    fbb_.Required(o, BaseTransportDump::VT_TRACEEVENTTYPES);
    return o;
  }
};

inline flatbuffers::Offset<BaseTransportDump> CreateBaseTransportDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    bool direct = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> producerIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> consumerIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> mapSsrcConsumerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::Uint32String>>> mapRtxSsrcConsumerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dataProducerIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dataConsumerIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Common::StringUint8>>> recvRtpHeaderExtensions = 0,
    flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener = 0,
    uint32_t maxMessageSize = 0,
    flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters = 0,
    flatbuffers::Offset<flatbuffers::String> sctpState = 0,
    flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> traceEventTypes = 0) {
  BaseTransportDumpBuilder builder_(_fbb);
  builder_.add_traceEventTypes(traceEventTypes);
  builder_.add_sctpListener(sctpListener);
  builder_.add_sctpState(sctpState);
  builder_.add_sctpParameters(sctpParameters);
  builder_.add_maxMessageSize(maxMessageSize);
  builder_.add_rtpListener(rtpListener);
  builder_.add_recvRtpHeaderExtensions(recvRtpHeaderExtensions);
  builder_.add_dataConsumerIds(dataConsumerIds);
  builder_.add_dataProducerIds(dataProducerIds);
  builder_.add_mapRtxSsrcConsumerId(mapRtxSsrcConsumerId);
  builder_.add_mapSsrcConsumerId(mapSsrcConsumerId);
  builder_.add_consumerIds(consumerIds);
  builder_.add_producerIds(producerIds);
  builder_.add_id(id);
  builder_.add_direct(direct);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseTransportDump> CreateBaseTransportDumpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    bool direct = false,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *producerIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *consumerIds = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Common::Uint32String>> *mapSsrcConsumerId = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Common::Uint32String>> *mapRtxSsrcConsumerId = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dataProducerIds = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dataConsumerIds = nullptr,
    const std::vector<flatbuffers::Offset<FBS::Common::StringUint8>> *recvRtpHeaderExtensions = nullptr,
    flatbuffers::Offset<FBS::Transport::RtpListener> rtpListener = 0,
    uint32_t maxMessageSize = 0,
    flatbuffers::Offset<FBS::SctpParameters::SctpParameters> sctpParameters = 0,
    const char *sctpState = nullptr,
    flatbuffers::Offset<FBS::Transport::SctpListener> sctpListener = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *traceEventTypes = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto producerIds__ = producerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*producerIds) : 0;
  auto consumerIds__ = consumerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*consumerIds) : 0;
  auto mapSsrcConsumerId__ = mapSsrcConsumerId ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::Uint32String>>(*mapSsrcConsumerId) : 0;
  auto mapRtxSsrcConsumerId__ = mapRtxSsrcConsumerId ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::Uint32String>>(*mapRtxSsrcConsumerId) : 0;
  auto dataProducerIds__ = dataProducerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dataProducerIds) : 0;
  auto dataConsumerIds__ = dataConsumerIds ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dataConsumerIds) : 0;
  auto recvRtpHeaderExtensions__ = recvRtpHeaderExtensions ? _fbb.CreateVector<flatbuffers::Offset<FBS::Common::StringUint8>>(*recvRtpHeaderExtensions) : 0;
  auto sctpState__ = sctpState ? _fbb.CreateString(sctpState) : 0;
  auto traceEventTypes__ = traceEventTypes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*traceEventTypes) : 0;
  return FBS::Transport::CreateBaseTransportDump(
      _fbb,
      id__,
      direct,
      producerIds__,
      consumerIds__,
      mapSsrcConsumerId__,
      mapRtxSsrcConsumerId__,
      dataProducerIds__,
      dataConsumerIds__,
      recvRtpHeaderExtensions__,
      rtpListener,
      maxMessageSize,
      sctpParameters,
      sctpState__,
      sctpListener,
      traceEventTypes__);
}

struct IceParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IceParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USERNAMEFRAGMENT = 4,
    VT_PASSWORD = 6,
    VT_ICELITE = 8
  };
  const flatbuffers::String *usernameFragment() const {
    return GetPointer<const flatbuffers::String *>(VT_USERNAMEFRAGMENT);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool iceLite() const {
    return GetField<uint8_t>(VT_ICELITE, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_USERNAMEFRAGMENT) &&
           verifier.VerifyString(usernameFragment()) &&
           VerifyOffsetRequired(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           VerifyField<uint8_t>(verifier, VT_ICELITE, 1) &&
           verifier.EndTable();
  }
};

struct IceParametersBuilder {
  typedef IceParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_usernameFragment(flatbuffers::Offset<flatbuffers::String> usernameFragment) {
    fbb_.AddOffset(IceParameters::VT_USERNAMEFRAGMENT, usernameFragment);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(IceParameters::VT_PASSWORD, password);
  }
  void add_iceLite(bool iceLite) {
    fbb_.AddElement<uint8_t>(IceParameters::VT_ICELITE, static_cast<uint8_t>(iceLite), 1);
  }
  explicit IceParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IceParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IceParameters>(end);
    fbb_.Required(o, IceParameters::VT_USERNAMEFRAGMENT);
    fbb_.Required(o, IceParameters::VT_PASSWORD);
    return o;
  }
};

inline flatbuffers::Offset<IceParameters> CreateIceParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> usernameFragment = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0,
    bool iceLite = true) {
  IceParametersBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_usernameFragment(usernameFragment);
  builder_.add_iceLite(iceLite);
  return builder_.Finish();
}

inline flatbuffers::Offset<IceParameters> CreateIceParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *usernameFragment = nullptr,
    const char *password = nullptr,
    bool iceLite = true) {
  auto usernameFragment__ = usernameFragment ? _fbb.CreateString(usernameFragment) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return FBS::Transport::CreateIceParameters(
      _fbb,
      usernameFragment__,
      password__,
      iceLite);
}

struct IceCandidate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IceCandidateBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IceCandidateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOUNDATION = 4,
    VT_PRIORITY = 6,
    VT_IP = 8,
    VT_PROTOCOL = 10,
    VT_PORT = 12,
    VT_TYPE = 14,
    VT_TCPTYPE = 16
  };
  const flatbuffers::String *foundation() const {
    return GetPointer<const flatbuffers::String *>(VT_FOUNDATION);
  }
  uint32_t priority() const {
    return GetField<uint32_t>(VT_PRIORITY, 0);
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *tcpType() const {
    return GetPointer<const flatbuffers::String *>(VT_TCPTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FOUNDATION) &&
           verifier.VerifyString(foundation()) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyOffsetRequired(verifier, VT_IP) &&
           verifier.VerifyString(ip()) &&
           VerifyOffsetRequired(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TCPTYPE) &&
           verifier.VerifyString(tcpType()) &&
           verifier.EndTable();
  }
};

struct IceCandidateBuilder {
  typedef IceCandidate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_foundation(flatbuffers::Offset<flatbuffers::String> foundation) {
    fbb_.AddOffset(IceCandidate::VT_FOUNDATION, foundation);
  }
  void add_priority(uint32_t priority) {
    fbb_.AddElement<uint32_t>(IceCandidate::VT_PRIORITY, priority, 0);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(IceCandidate::VT_IP, ip);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(IceCandidate::VT_PROTOCOL, protocol);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(IceCandidate::VT_PORT, port, 0);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(IceCandidate::VT_TYPE, type);
  }
  void add_tcpType(flatbuffers::Offset<flatbuffers::String> tcpType) {
    fbb_.AddOffset(IceCandidate::VT_TCPTYPE, tcpType);
  }
  explicit IceCandidateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IceCandidate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IceCandidate>(end);
    fbb_.Required(o, IceCandidate::VT_FOUNDATION);
    fbb_.Required(o, IceCandidate::VT_IP);
    fbb_.Required(o, IceCandidate::VT_PROTOCOL);
    return o;
  }
};

inline flatbuffers::Offset<IceCandidate> CreateIceCandidate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> foundation = 0,
    uint32_t priority = 0,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    uint16_t port = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> tcpType = 0) {
  IceCandidateBuilder builder_(_fbb);
  builder_.add_tcpType(tcpType);
  builder_.add_type(type);
  builder_.add_protocol(protocol);
  builder_.add_ip(ip);
  builder_.add_priority(priority);
  builder_.add_foundation(foundation);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<IceCandidate> CreateIceCandidateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *foundation = nullptr,
    uint32_t priority = 0,
    const char *ip = nullptr,
    const char *protocol = nullptr,
    uint16_t port = 0,
    const char *type = nullptr,
    const char *tcpType = nullptr) {
  auto foundation__ = foundation ? _fbb.CreateString(foundation) : 0;
  auto ip__ = ip ? _fbb.CreateString(ip) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto tcpType__ = tcpType ? _fbb.CreateString(tcpType) : 0;
  return FBS::Transport::CreateIceCandidate(
      _fbb,
      foundation__,
      priority,
      ip__,
      protocol__,
      port,
      type__,
      tcpType__);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TupleTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALIP = 4,
    VT_LOCALPORT = 6,
    VT_REMOTEIP = 8,
    VT_REMOTEPORT = 10,
    VT_PROTOCOL = 12
  };
  const flatbuffers::String *localIp() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALIP);
  }
  uint16_t localPort() const {
    return GetField<uint16_t>(VT_LOCALPORT, 0);
  }
  const flatbuffers::String *remoteIp() const {
    return GetPointer<const flatbuffers::String *>(VT_REMOTEIP);
  }
  uint16_t remotePort() const {
    return GetField<uint16_t>(VT_REMOTEPORT, 0);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOCALIP) &&
           verifier.VerifyString(localIp()) &&
           VerifyField<uint16_t>(verifier, VT_LOCALPORT, 2) &&
           VerifyOffsetRequired(verifier, VT_REMOTEIP) &&
           verifier.VerifyString(remoteIp()) &&
           VerifyField<uint16_t>(verifier, VT_REMOTEPORT, 2) &&
           VerifyOffsetRequired(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  typedef Tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_localIp(flatbuffers::Offset<flatbuffers::String> localIp) {
    fbb_.AddOffset(Tuple::VT_LOCALIP, localIp);
  }
  void add_localPort(uint16_t localPort) {
    fbb_.AddElement<uint16_t>(Tuple::VT_LOCALPORT, localPort, 0);
  }
  void add_remoteIp(flatbuffers::Offset<flatbuffers::String> remoteIp) {
    fbb_.AddOffset(Tuple::VT_REMOTEIP, remoteIp);
  }
  void add_remotePort(uint16_t remotePort) {
    fbb_.AddElement<uint16_t>(Tuple::VT_REMOTEPORT, remotePort, 0);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(Tuple::VT_PROTOCOL, protocol);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    fbb_.Required(o, Tuple::VT_LOCALIP);
    fbb_.Required(o, Tuple::VT_REMOTEIP);
    fbb_.Required(o, Tuple::VT_PROTOCOL);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> localIp = 0,
    uint16_t localPort = 0,
    flatbuffers::Offset<flatbuffers::String> remoteIp = 0,
    uint16_t remotePort = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_protocol(protocol);
  builder_.add_remoteIp(remoteIp);
  builder_.add_localIp(localIp);
  builder_.add_remotePort(remotePort);
  builder_.add_localPort(localPort);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *localIp = nullptr,
    uint16_t localPort = 0,
    const char *remoteIp = nullptr,
    uint16_t remotePort = 0,
    const char *protocol = nullptr) {
  auto localIp__ = localIp ? _fbb.CreateString(localIp) : 0;
  auto remoteIp__ = remoteIp ? _fbb.CreateString(remoteIp) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  return FBS::Transport::CreateTuple(
      _fbb,
      localIp__,
      localPort,
      remoteIp__,
      remotePort,
      protocol__);
}

struct Fingerprint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FingerprintBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FingerprintTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALGORITHM = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *algorithm() const {
    return GetPointer<const flatbuffers::String *>(VT_ALGORITHM);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ALGORITHM) &&
           verifier.VerifyString(algorithm()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct FingerprintBuilder {
  typedef Fingerprint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_algorithm(flatbuffers::Offset<flatbuffers::String> algorithm) {
    fbb_.AddOffset(Fingerprint::VT_ALGORITHM, algorithm);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Fingerprint::VT_VALUE, value);
  }
  explicit FingerprintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fingerprint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fingerprint>(end);
    fbb_.Required(o, Fingerprint::VT_ALGORITHM);
    fbb_.Required(o, Fingerprint::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<Fingerprint> CreateFingerprint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> algorithm = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  FingerprintBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_algorithm(algorithm);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fingerprint> CreateFingerprintDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *algorithm = nullptr,
    const char *value = nullptr) {
  auto algorithm__ = algorithm ? _fbb.CreateString(algorithm) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return FBS::Transport::CreateFingerprint(
      _fbb,
      algorithm__,
      value__);
}

struct DtlsParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DtlsParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DtlsParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FINGERPRINTS = 4,
    VT_ROLE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::Fingerprint>> *fingerprints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::Fingerprint>> *>(VT_FINGERPRINTS);
  }
  const flatbuffers::String *role() const {
    return GetPointer<const flatbuffers::String *>(VT_ROLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FINGERPRINTS) &&
           verifier.VerifyVector(fingerprints()) &&
           verifier.VerifyVectorOfTables(fingerprints()) &&
           VerifyOffsetRequired(verifier, VT_ROLE) &&
           verifier.VerifyString(role()) &&
           verifier.EndTable();
  }
};

struct DtlsParametersBuilder {
  typedef DtlsParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fingerprints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::Fingerprint>>> fingerprints) {
    fbb_.AddOffset(DtlsParameters::VT_FINGERPRINTS, fingerprints);
  }
  void add_role(flatbuffers::Offset<flatbuffers::String> role) {
    fbb_.AddOffset(DtlsParameters::VT_ROLE, role);
  }
  explicit DtlsParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DtlsParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DtlsParameters>(end);
    fbb_.Required(o, DtlsParameters::VT_FINGERPRINTS);
    fbb_.Required(o, DtlsParameters::VT_ROLE);
    return o;
  }
};

inline flatbuffers::Offset<DtlsParameters> CreateDtlsParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::Fingerprint>>> fingerprints = 0,
    flatbuffers::Offset<flatbuffers::String> role = 0) {
  DtlsParametersBuilder builder_(_fbb);
  builder_.add_role(role);
  builder_.add_fingerprints(fingerprints);
  return builder_.Finish();
}

inline flatbuffers::Offset<DtlsParameters> CreateDtlsParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FBS::Transport::Fingerprint>> *fingerprints = nullptr,
    const char *role = nullptr) {
  auto fingerprints__ = fingerprints ? _fbb.CreateVector<flatbuffers::Offset<FBS::Transport::Fingerprint>>(*fingerprints) : 0;
  auto role__ = role ? _fbb.CreateString(role) : 0;
  return FBS::Transport::CreateDtlsParameters(
      _fbb,
      fingerprints__,
      role__);
}

struct WebRtcTransportDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WebRtcTransportDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WebRtcTransportDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_ICEROLE = 6,
    VT_ICEPARAMETERS = 8,
    VT_ICECANDIDATES = 10,
    VT_ICESTATE = 12,
    VT_ICESELECTEDTUPLE = 14,
    VT_DTLSPARAMETERS = 16,
    VT_DTLSSTATE = 18
  };
  const FBS::Transport::DumpResponse *base() const {
    return GetPointer<const FBS::Transport::DumpResponse *>(VT_BASE);
  }
  const flatbuffers::String *iceRole() const {
    return GetPointer<const flatbuffers::String *>(VT_ICEROLE);
  }
  const FBS::Transport::IceParameters *iceParameters() const {
    return GetPointer<const FBS::Transport::IceParameters *>(VT_ICEPARAMETERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::IceCandidate>> *iceCandidates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::IceCandidate>> *>(VT_ICECANDIDATES);
  }
  const flatbuffers::String *iceState() const {
    return GetPointer<const flatbuffers::String *>(VT_ICESTATE);
  }
  const FBS::Transport::Tuple *iceSelectedTuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_ICESELECTEDTUPLE);
  }
  const FBS::Transport::DtlsParameters *dtlsParameters() const {
    return GetPointer<const FBS::Transport::DtlsParameters *>(VT_DTLSPARAMETERS);
  }
  const flatbuffers::String *dtlsState() const {
    return GetPointer<const flatbuffers::String *>(VT_DTLSSTATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_ICEROLE) &&
           verifier.VerifyString(iceRole()) &&
           VerifyOffsetRequired(verifier, VT_ICEPARAMETERS) &&
           verifier.VerifyTable(iceParameters()) &&
           VerifyOffsetRequired(verifier, VT_ICECANDIDATES) &&
           verifier.VerifyVector(iceCandidates()) &&
           verifier.VerifyVectorOfTables(iceCandidates()) &&
           VerifyOffsetRequired(verifier, VT_ICESTATE) &&
           verifier.VerifyString(iceState()) &&
           VerifyOffset(verifier, VT_ICESELECTEDTUPLE) &&
           verifier.VerifyTable(iceSelectedTuple()) &&
           VerifyOffsetRequired(verifier, VT_DTLSPARAMETERS) &&
           verifier.VerifyTable(dtlsParameters()) &&
           VerifyOffsetRequired(verifier, VT_DTLSSTATE) &&
           verifier.VerifyString(dtlsState()) &&
           verifier.EndTable();
  }
};

struct WebRtcTransportDumpBuilder {
  typedef WebRtcTransportDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<FBS::Transport::DumpResponse> base) {
    fbb_.AddOffset(WebRtcTransportDump::VT_BASE, base);
  }
  void add_iceRole(flatbuffers::Offset<flatbuffers::String> iceRole) {
    fbb_.AddOffset(WebRtcTransportDump::VT_ICEROLE, iceRole);
  }
  void add_iceParameters(flatbuffers::Offset<FBS::Transport::IceParameters> iceParameters) {
    fbb_.AddOffset(WebRtcTransportDump::VT_ICEPARAMETERS, iceParameters);
  }
  void add_iceCandidates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::IceCandidate>>> iceCandidates) {
    fbb_.AddOffset(WebRtcTransportDump::VT_ICECANDIDATES, iceCandidates);
  }
  void add_iceState(flatbuffers::Offset<flatbuffers::String> iceState) {
    fbb_.AddOffset(WebRtcTransportDump::VT_ICESTATE, iceState);
  }
  void add_iceSelectedTuple(flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple) {
    fbb_.AddOffset(WebRtcTransportDump::VT_ICESELECTEDTUPLE, iceSelectedTuple);
  }
  void add_dtlsParameters(flatbuffers::Offset<FBS::Transport::DtlsParameters> dtlsParameters) {
    fbb_.AddOffset(WebRtcTransportDump::VT_DTLSPARAMETERS, dtlsParameters);
  }
  void add_dtlsState(flatbuffers::Offset<flatbuffers::String> dtlsState) {
    fbb_.AddOffset(WebRtcTransportDump::VT_DTLSSTATE, dtlsState);
  }
  explicit WebRtcTransportDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WebRtcTransportDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebRtcTransportDump>(end);
    fbb_.Required(o, WebRtcTransportDump::VT_BASE);
    fbb_.Required(o, WebRtcTransportDump::VT_ICEROLE);
    fbb_.Required(o, WebRtcTransportDump::VT_ICEPARAMETERS);
    fbb_.Required(o, WebRtcTransportDump::VT_ICECANDIDATES);
    fbb_.Required(o, WebRtcTransportDump::VT_ICESTATE);
    fbb_.Required(o, WebRtcTransportDump::VT_DTLSPARAMETERS);
    fbb_.Required(o, WebRtcTransportDump::VT_DTLSSTATE);
    return o;
  }
};

inline flatbuffers::Offset<WebRtcTransportDump> CreateWebRtcTransportDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::DumpResponse> base = 0,
    flatbuffers::Offset<flatbuffers::String> iceRole = 0,
    flatbuffers::Offset<FBS::Transport::IceParameters> iceParameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBS::Transport::IceCandidate>>> iceCandidates = 0,
    flatbuffers::Offset<flatbuffers::String> iceState = 0,
    flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    flatbuffers::Offset<FBS::Transport::DtlsParameters> dtlsParameters = 0,
    flatbuffers::Offset<flatbuffers::String> dtlsState = 0) {
  WebRtcTransportDumpBuilder builder_(_fbb);
  builder_.add_dtlsState(dtlsState);
  builder_.add_dtlsParameters(dtlsParameters);
  builder_.add_iceSelectedTuple(iceSelectedTuple);
  builder_.add_iceState(iceState);
  builder_.add_iceCandidates(iceCandidates);
  builder_.add_iceParameters(iceParameters);
  builder_.add_iceRole(iceRole);
  builder_.add_base(base);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebRtcTransportDump> CreateWebRtcTransportDumpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::DumpResponse> base = 0,
    const char *iceRole = nullptr,
    flatbuffers::Offset<FBS::Transport::IceParameters> iceParameters = 0,
    const std::vector<flatbuffers::Offset<FBS::Transport::IceCandidate>> *iceCandidates = nullptr,
    const char *iceState = nullptr,
    flatbuffers::Offset<FBS::Transport::Tuple> iceSelectedTuple = 0,
    flatbuffers::Offset<FBS::Transport::DtlsParameters> dtlsParameters = 0,
    const char *dtlsState = nullptr) {
  auto iceRole__ = iceRole ? _fbb.CreateString(iceRole) : 0;
  auto iceCandidates__ = iceCandidates ? _fbb.CreateVector<flatbuffers::Offset<FBS::Transport::IceCandidate>>(*iceCandidates) : 0;
  auto iceState__ = iceState ? _fbb.CreateString(iceState) : 0;
  auto dtlsState__ = dtlsState ? _fbb.CreateString(dtlsState) : 0;
  return FBS::Transport::CreateWebRtcTransportDump(
      _fbb,
      base,
      iceRole__,
      iceParameters,
      iceCandidates__,
      iceState__,
      iceSelectedTuple,
      dtlsParameters,
      dtlsState__);
}

struct SrtpParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SrtpParametersBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SrtpParametersTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRYPTOSUITE = 4,
    VT_KEYBASE64 = 6
  };
  const flatbuffers::String *cryptoSuite() const {
    return GetPointer<const flatbuffers::String *>(VT_CRYPTOSUITE);
  }
  const flatbuffers::String *keyBase64() const {
    return GetPointer<const flatbuffers::String *>(VT_KEYBASE64);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CRYPTOSUITE) &&
           verifier.VerifyString(cryptoSuite()) &&
           VerifyOffsetRequired(verifier, VT_KEYBASE64) &&
           verifier.VerifyString(keyBase64()) &&
           verifier.EndTable();
  }
};

struct SrtpParametersBuilder {
  typedef SrtpParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cryptoSuite(flatbuffers::Offset<flatbuffers::String> cryptoSuite) {
    fbb_.AddOffset(SrtpParameters::VT_CRYPTOSUITE, cryptoSuite);
  }
  void add_keyBase64(flatbuffers::Offset<flatbuffers::String> keyBase64) {
    fbb_.AddOffset(SrtpParameters::VT_KEYBASE64, keyBase64);
  }
  explicit SrtpParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SrtpParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SrtpParameters>(end);
    fbb_.Required(o, SrtpParameters::VT_CRYPTOSUITE);
    fbb_.Required(o, SrtpParameters::VT_KEYBASE64);
    return o;
  }
};

inline flatbuffers::Offset<SrtpParameters> CreateSrtpParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cryptoSuite = 0,
    flatbuffers::Offset<flatbuffers::String> keyBase64 = 0) {
  SrtpParametersBuilder builder_(_fbb);
  builder_.add_keyBase64(keyBase64);
  builder_.add_cryptoSuite(cryptoSuite);
  return builder_.Finish();
}

inline flatbuffers::Offset<SrtpParameters> CreateSrtpParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cryptoSuite = nullptr,
    const char *keyBase64 = nullptr) {
  auto cryptoSuite__ = cryptoSuite ? _fbb.CreateString(cryptoSuite) : 0;
  auto keyBase64__ = keyBase64 ? _fbb.CreateString(keyBase64) : 0;
  return FBS::Transport::CreateSrtpParameters(
      _fbb,
      cryptoSuite__,
      keyBase64__);
}

struct PlainTransportDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlainTransportDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlainTransportDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_RTCMUX = 6,
    VT_COMEDIA = 8,
    VT_TUPLE = 10,
    VT_RTCPTUPLE = 12,
    VT_SRTPPARAMETERS = 14
  };
  const FBS::Transport::DumpResponse *base() const {
    return GetPointer<const FBS::Transport::DumpResponse *>(VT_BASE);
  }
  bool rtcMux() const {
    return GetField<uint8_t>(VT_RTCMUX, 0) != 0;
  }
  bool comedia() const {
    return GetField<uint8_t>(VT_COMEDIA, 0) != 0;
  }
  const FBS::Transport::Tuple *tuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_TUPLE);
  }
  const FBS::Transport::Tuple *rtcpTuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_RTCPTUPLE);
  }
  const FBS::Transport::SrtpParameters *srtpParameters() const {
    return GetPointer<const FBS::Transport::SrtpParameters *>(VT_SRTPPARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyField<uint8_t>(verifier, VT_RTCMUX, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMEDIA, 1) &&
           VerifyOffset(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           VerifyOffset(verifier, VT_RTCPTUPLE) &&
           verifier.VerifyTable(rtcpTuple()) &&
           VerifyOffset(verifier, VT_SRTPPARAMETERS) &&
           verifier.VerifyTable(srtpParameters()) &&
           verifier.EndTable();
  }
};

struct PlainTransportDumpBuilder {
  typedef PlainTransportDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<FBS::Transport::DumpResponse> base) {
    fbb_.AddOffset(PlainTransportDump::VT_BASE, base);
  }
  void add_rtcMux(bool rtcMux) {
    fbb_.AddElement<uint8_t>(PlainTransportDump::VT_RTCMUX, static_cast<uint8_t>(rtcMux), 0);
  }
  void add_comedia(bool comedia) {
    fbb_.AddElement<uint8_t>(PlainTransportDump::VT_COMEDIA, static_cast<uint8_t>(comedia), 0);
  }
  void add_tuple(flatbuffers::Offset<FBS::Transport::Tuple> tuple) {
    fbb_.AddOffset(PlainTransportDump::VT_TUPLE, tuple);
  }
  void add_rtcpTuple(flatbuffers::Offset<FBS::Transport::Tuple> rtcpTuple) {
    fbb_.AddOffset(PlainTransportDump::VT_RTCPTUPLE, rtcpTuple);
  }
  void add_srtpParameters(flatbuffers::Offset<FBS::Transport::SrtpParameters> srtpParameters) {
    fbb_.AddOffset(PlainTransportDump::VT_SRTPPARAMETERS, srtpParameters);
  }
  explicit PlainTransportDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PlainTransportDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlainTransportDump>(end);
    fbb_.Required(o, PlainTransportDump::VT_BASE);
    return o;
  }
};

inline flatbuffers::Offset<PlainTransportDump> CreatePlainTransportDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::DumpResponse> base = 0,
    bool rtcMux = false,
    bool comedia = false,
    flatbuffers::Offset<FBS::Transport::Tuple> tuple = 0,
    flatbuffers::Offset<FBS::Transport::Tuple> rtcpTuple = 0,
    flatbuffers::Offset<FBS::Transport::SrtpParameters> srtpParameters = 0) {
  PlainTransportDumpBuilder builder_(_fbb);
  builder_.add_srtpParameters(srtpParameters);
  builder_.add_rtcpTuple(rtcpTuple);
  builder_.add_tuple(tuple);
  builder_.add_base(base);
  builder_.add_comedia(comedia);
  builder_.add_rtcMux(rtcMux);
  return builder_.Finish();
}

struct DirectTransportDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DirectTransportDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DirectTransportDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4
  };
  const FBS::Transport::DumpResponse *base() const {
    return GetPointer<const FBS::Transport::DumpResponse *>(VT_BASE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           verifier.EndTable();
  }
};

struct DirectTransportDumpBuilder {
  typedef DirectTransportDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<FBS::Transport::DumpResponse> base) {
    fbb_.AddOffset(DirectTransportDump::VT_BASE, base);
  }
  explicit DirectTransportDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DirectTransportDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DirectTransportDump>(end);
    fbb_.Required(o, DirectTransportDump::VT_BASE);
    return o;
  }
};

inline flatbuffers::Offset<DirectTransportDump> CreateDirectTransportDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::DumpResponse> base = 0) {
  DirectTransportDumpBuilder builder_(_fbb);
  builder_.add_base(base);
  return builder_.Finish();
}

struct PipeTransportDump FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PipeTransportDumpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PipeTransportDumpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_TUPLE = 6,
    VT_RTX = 8,
    VT_SRTPPARAMETERS = 10
  };
  const FBS::Transport::DumpResponse *base() const {
    return GetPointer<const FBS::Transport::DumpResponse *>(VT_BASE);
  }
  const FBS::Transport::Tuple *tuple() const {
    return GetPointer<const FBS::Transport::Tuple *>(VT_TUPLE);
  }
  bool rtx() const {
    return GetField<uint8_t>(VT_RTX, 0) != 0;
  }
  const FBS::Transport::SrtpParameters *srtpParameters() const {
    return GetPointer<const FBS::Transport::SrtpParameters *>(VT_SRTPPARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BASE) &&
           verifier.VerifyTable(base()) &&
           VerifyOffsetRequired(verifier, VT_TUPLE) &&
           verifier.VerifyTable(tuple()) &&
           VerifyField<uint8_t>(verifier, VT_RTX, 1) &&
           VerifyOffset(verifier, VT_SRTPPARAMETERS) &&
           verifier.VerifyTable(srtpParameters()) &&
           verifier.EndTable();
  }
};

struct PipeTransportDumpBuilder {
  typedef PipeTransportDump Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(flatbuffers::Offset<FBS::Transport::DumpResponse> base) {
    fbb_.AddOffset(PipeTransportDump::VT_BASE, base);
  }
  void add_tuple(flatbuffers::Offset<FBS::Transport::Tuple> tuple) {
    fbb_.AddOffset(PipeTransportDump::VT_TUPLE, tuple);
  }
  void add_rtx(bool rtx) {
    fbb_.AddElement<uint8_t>(PipeTransportDump::VT_RTX, static_cast<uint8_t>(rtx), 0);
  }
  void add_srtpParameters(flatbuffers::Offset<FBS::Transport::SrtpParameters> srtpParameters) {
    fbb_.AddOffset(PipeTransportDump::VT_SRTPPARAMETERS, srtpParameters);
  }
  explicit PipeTransportDumpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PipeTransportDump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PipeTransportDump>(end);
    fbb_.Required(o, PipeTransportDump::VT_BASE);
    fbb_.Required(o, PipeTransportDump::VT_TUPLE);
    return o;
  }
};

inline flatbuffers::Offset<PipeTransportDump> CreatePipeTransportDump(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FBS::Transport::DumpResponse> base = 0,
    flatbuffers::Offset<FBS::Transport::Tuple> tuple = 0,
    bool rtx = false,
    flatbuffers::Offset<FBS::Transport::SrtpParameters> srtpParameters = 0) {
  PipeTransportDumpBuilder builder_(_fbb);
  builder_.add_srtpParameters(srtpParameters);
  builder_.add_tuple(tuple);
  builder_.add_base(base);
  builder_.add_rtx(rtx);
  return builder_.Finish();
}

struct BaseTransportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BaseTransportOptionsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BaseTransportOptionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRECT = 4,
    VT_MAXMESSAGESIZE = 6,
    VT_INITIALAVAILABLEOUTGOINGBITRATE = 8,
    VT_ENABLESCTP = 10,
    VT_NUMSCTPSTREAMS = 12,
    VT_MAXSCTPMESSAGESIZE = 14,
    VT_SCTPSENDBUFFERSIZE = 16,
    VT_ISDATACHANNEL = 18
  };
  bool direct() const {
    return GetField<uint8_t>(VT_DIRECT, 0) != 0;
  }
  uint32_t maxMessageSize() const {
    return GetField<uint32_t>(VT_MAXMESSAGESIZE, 0);
  }
  uint32_t initialAvailableOutgoingBitrate() const {
    return GetField<uint32_t>(VT_INITIALAVAILABLEOUTGOINGBITRATE, 0);
  }
  bool enableSctp() const {
    return GetField<uint8_t>(VT_ENABLESCTP, 0) != 0;
  }
  const FBS::SctpParameters::NumSctpStreams *numSctpStreams() const {
    return GetPointer<const FBS::SctpParameters::NumSctpStreams *>(VT_NUMSCTPSTREAMS);
  }
  uint32_t maxSctpMessageSize() const {
    return GetField<uint32_t>(VT_MAXSCTPMESSAGESIZE, 0);
  }
  uint32_t sctpSendBufferSize() const {
    return GetField<uint32_t>(VT_SCTPSENDBUFFERSIZE, 0);
  }
  bool isDataChannel() const {
    return GetField<uint8_t>(VT_ISDATACHANNEL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIRECT, 1) &&
           VerifyField<uint32_t>(verifier, VT_MAXMESSAGESIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_INITIALAVAILABLEOUTGOINGBITRATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ENABLESCTP, 1) &&
           VerifyOffset(verifier, VT_NUMSCTPSTREAMS) &&
           verifier.VerifyTable(numSctpStreams()) &&
           VerifyField<uint32_t>(verifier, VT_MAXSCTPMESSAGESIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SCTPSENDBUFFERSIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISDATACHANNEL, 1) &&
           verifier.EndTable();
  }
};

struct BaseTransportOptionsBuilder {
  typedef BaseTransportOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_direct(bool direct) {
    fbb_.AddElement<uint8_t>(BaseTransportOptions::VT_DIRECT, static_cast<uint8_t>(direct), 0);
  }
  void add_maxMessageSize(uint32_t maxMessageSize) {
    fbb_.AddElement<uint32_t>(BaseTransportOptions::VT_MAXMESSAGESIZE, maxMessageSize, 0);
  }
  void add_initialAvailableOutgoingBitrate(uint32_t initialAvailableOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(BaseTransportOptions::VT_INITIALAVAILABLEOUTGOINGBITRATE, initialAvailableOutgoingBitrate, 0);
  }
  void add_enableSctp(bool enableSctp) {
    fbb_.AddElement<uint8_t>(BaseTransportOptions::VT_ENABLESCTP, static_cast<uint8_t>(enableSctp), 0);
  }
  void add_numSctpStreams(flatbuffers::Offset<FBS::SctpParameters::NumSctpStreams> numSctpStreams) {
    fbb_.AddOffset(BaseTransportOptions::VT_NUMSCTPSTREAMS, numSctpStreams);
  }
  void add_maxSctpMessageSize(uint32_t maxSctpMessageSize) {
    fbb_.AddElement<uint32_t>(BaseTransportOptions::VT_MAXSCTPMESSAGESIZE, maxSctpMessageSize, 0);
  }
  void add_sctpSendBufferSize(uint32_t sctpSendBufferSize) {
    fbb_.AddElement<uint32_t>(BaseTransportOptions::VT_SCTPSENDBUFFERSIZE, sctpSendBufferSize, 0);
  }
  void add_isDataChannel(bool isDataChannel) {
    fbb_.AddElement<uint8_t>(BaseTransportOptions::VT_ISDATACHANNEL, static_cast<uint8_t>(isDataChannel), 0);
  }
  explicit BaseTransportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BaseTransportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BaseTransportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BaseTransportOptions> CreateBaseTransportOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool direct = false,
    uint32_t maxMessageSize = 0,
    uint32_t initialAvailableOutgoingBitrate = 0,
    bool enableSctp = false,
    flatbuffers::Offset<FBS::SctpParameters::NumSctpStreams> numSctpStreams = 0,
    uint32_t maxSctpMessageSize = 0,
    uint32_t sctpSendBufferSize = 0,
    bool isDataChannel = false) {
  BaseTransportOptionsBuilder builder_(_fbb);
  builder_.add_sctpSendBufferSize(sctpSendBufferSize);
  builder_.add_maxSctpMessageSize(maxSctpMessageSize);
  builder_.add_numSctpStreams(numSctpStreams);
  builder_.add_initialAvailableOutgoingBitrate(initialAvailableOutgoingBitrate);
  builder_.add_maxMessageSize(maxMessageSize);
  builder_.add_isDataChannel(isDataChannel);
  builder_.add_enableSctp(enableSctp);
  builder_.add_direct(direct);
  return builder_.Finish();
}

struct SetMaxIncomingBitrateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetMaxIncomingBitrateRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetMaxIncomingBitrateRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXINCOMINGBITRATE = 4
  };
  uint32_t maxIncomingBitrate() const {
    return GetField<uint32_t>(VT_MAXINCOMINGBITRATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAXINCOMINGBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct SetMaxIncomingBitrateRequestBuilder {
  typedef SetMaxIncomingBitrateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxIncomingBitrate(uint32_t maxIncomingBitrate) {
    fbb_.AddElement<uint32_t>(SetMaxIncomingBitrateRequest::VT_MAXINCOMINGBITRATE, maxIncomingBitrate, 0);
  }
  explicit SetMaxIncomingBitrateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetMaxIncomingBitrateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetMaxIncomingBitrateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetMaxIncomingBitrateRequest> CreateSetMaxIncomingBitrateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t maxIncomingBitrate = 0) {
  SetMaxIncomingBitrateRequestBuilder builder_(_fbb);
  builder_.add_maxIncomingBitrate(maxIncomingBitrate);
  return builder_.Finish();
}

struct SetMaxOutgoingBitrateRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SetMaxOutgoingBitrateRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetMaxOutgoingBitrateRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXOUTGOINGBITRATE = 4
  };
  uint32_t maxOutgoingBitrate() const {
    return GetField<uint32_t>(VT_MAXOUTGOINGBITRATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAXOUTGOINGBITRATE, 4) &&
           verifier.EndTable();
  }
};

struct SetMaxOutgoingBitrateRequestBuilder {
  typedef SetMaxOutgoingBitrateRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxOutgoingBitrate(uint32_t maxOutgoingBitrate) {
    fbb_.AddElement<uint32_t>(SetMaxOutgoingBitrateRequest::VT_MAXOUTGOINGBITRATE, maxOutgoingBitrate, 0);
  }
  explicit SetMaxOutgoingBitrateRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SetMaxOutgoingBitrateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SetMaxOutgoingBitrateRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SetMaxOutgoingBitrateRequest> CreateSetMaxOutgoingBitrateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t maxOutgoingBitrate = 0) {
  SetMaxOutgoingBitrateRequestBuilder builder_(_fbb);
  builder_.add_maxOutgoingBitrate(maxOutgoingBitrate);
  return builder_.Finish();
}

struct EnableTraceEventRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnableTraceEventRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return EnableTraceEventRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EVENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfStrings(events()) &&
           verifier.EndTable();
  }
};

struct EnableTraceEventRequestBuilder {
  typedef EnableTraceEventRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> events) {
    fbb_.AddOffset(EnableTraceEventRequest::VT_EVENTS, events);
  }
  explicit EnableTraceEventRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EnableTraceEventRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnableTraceEventRequest>(end);
    fbb_.Required(o, EnableTraceEventRequest::VT_EVENTS);
    return o;
  }
};

inline flatbuffers::Offset<EnableTraceEventRequest> CreateEnableTraceEventRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> events = 0) {
  EnableTraceEventRequestBuilder builder_(_fbb);
  builder_.add_events(events);
  return builder_.Finish();
}

inline flatbuffers::Offset<EnableTraceEventRequest> CreateEnableTraceEventRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *events = nullptr) {
  auto events__ = events ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*events) : 0;
  return FBS::Transport::CreateEnableTraceEventRequest(
      _fbb,
      events__);
}

struct CloseProducerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseProducerRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseProducerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCERID = 4
  };
  const flatbuffers::String *producerId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PRODUCERID) &&
           verifier.VerifyString(producerId()) &&
           verifier.EndTable();
  }
};

struct CloseProducerRequestBuilder {
  typedef CloseProducerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_producerId(flatbuffers::Offset<flatbuffers::String> producerId) {
    fbb_.AddOffset(CloseProducerRequest::VT_PRODUCERID, producerId);
  }
  explicit CloseProducerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseProducerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseProducerRequest>(end);
    fbb_.Required(o, CloseProducerRequest::VT_PRODUCERID);
    return o;
  }
};

inline flatbuffers::Offset<CloseProducerRequest> CreateCloseProducerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> producerId = 0) {
  CloseProducerRequestBuilder builder_(_fbb);
  builder_.add_producerId(producerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloseProducerRequest> CreateCloseProducerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *producerId = nullptr) {
  auto producerId__ = producerId ? _fbb.CreateString(producerId) : 0;
  return FBS::Transport::CreateCloseProducerRequest(
      _fbb,
      producerId__);
}

struct CloseConsumerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseConsumerRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseConsumerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSUMERID = 4
  };
  const flatbuffers::String *consumerId() const {
    return GetPointer<const flatbuffers::String *>(VT_CONSUMERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSUMERID) &&
           verifier.VerifyString(consumerId()) &&
           verifier.EndTable();
  }
};

struct CloseConsumerRequestBuilder {
  typedef CloseConsumerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_consumerId(flatbuffers::Offset<flatbuffers::String> consumerId) {
    fbb_.AddOffset(CloseConsumerRequest::VT_CONSUMERID, consumerId);
  }
  explicit CloseConsumerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseConsumerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseConsumerRequest>(end);
    fbb_.Required(o, CloseConsumerRequest::VT_CONSUMERID);
    return o;
  }
};

inline flatbuffers::Offset<CloseConsumerRequest> CreateCloseConsumerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> consumerId = 0) {
  CloseConsumerRequestBuilder builder_(_fbb);
  builder_.add_consumerId(consumerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloseConsumerRequest> CreateCloseConsumerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *consumerId = nullptr) {
  auto consumerId__ = consumerId ? _fbb.CreateString(consumerId) : 0;
  return FBS::Transport::CreateCloseConsumerRequest(
      _fbb,
      consumerId__);
}

struct CloseDataProducerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseDataProducerRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseDataProducerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAPRODUCERID = 4
  };
  const flatbuffers::String *dataProducerId() const {
    return GetPointer<const flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           verifier.EndTable();
  }
};

struct CloseDataProducerRequestBuilder {
  typedef CloseDataProducerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataProducerId(flatbuffers::Offset<flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(CloseDataProducerRequest::VT_DATAPRODUCERID, dataProducerId);
  }
  explicit CloseDataProducerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseDataProducerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseDataProducerRequest>(end);
    fbb_.Required(o, CloseDataProducerRequest::VT_DATAPRODUCERID);
    return o;
  }
};

inline flatbuffers::Offset<CloseDataProducerRequest> CreateCloseDataProducerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dataProducerId = 0) {
  CloseDataProducerRequestBuilder builder_(_fbb);
  builder_.add_dataProducerId(dataProducerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloseDataProducerRequest> CreateCloseDataProducerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataProducerId = nullptr) {
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  return FBS::Transport::CreateCloseDataProducerRequest(
      _fbb,
      dataProducerId__);
}

struct CloseDataConsumerRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CloseDataConsumerRequestBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CloseDataConsumerRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATACONSUMERID = 4
  };
  const flatbuffers::String *dataConsumerId() const {
    return GetPointer<const flatbuffers::String *>(VT_DATACONSUMERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATACONSUMERID) &&
           verifier.VerifyString(dataConsumerId()) &&
           verifier.EndTable();
  }
};

struct CloseDataConsumerRequestBuilder {
  typedef CloseDataConsumerRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataConsumerId(flatbuffers::Offset<flatbuffers::String> dataConsumerId) {
    fbb_.AddOffset(CloseDataConsumerRequest::VT_DATACONSUMERID, dataConsumerId);
  }
  explicit CloseDataConsumerRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CloseDataConsumerRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CloseDataConsumerRequest>(end);
    fbb_.Required(o, CloseDataConsumerRequest::VT_DATACONSUMERID);
    return o;
  }
};

inline flatbuffers::Offset<CloseDataConsumerRequest> CreateCloseDataConsumerRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> dataConsumerId = 0) {
  CloseDataConsumerRequestBuilder builder_(_fbb);
  builder_.add_dataConsumerId(dataConsumerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CloseDataConsumerRequest> CreateCloseDataConsumerRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *dataConsumerId = nullptr) {
  auto dataConsumerId__ = dataConsumerId ? _fbb.CreateString(dataConsumerId) : 0;
  return FBS::Transport::CreateCloseDataConsumerRequest(
      _fbb,
      dataConsumerId__);
}

inline bool VerifyTransportDumpData(flatbuffers::Verifier &verifier, const void *obj, TransportDumpData type) {
  switch (type) {
    case TransportDumpData::NONE: {
      return true;
    }
    case TransportDumpData::BaseTransportDump: {
      auto ptr = reinterpret_cast<const FBS::Transport::BaseTransportDump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TransportDumpData::DirectTransportDump: {
      auto ptr = reinterpret_cast<const FBS::Transport::DirectTransportDump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TransportDumpData::PipeTransportDump: {
      auto ptr = reinterpret_cast<const FBS::Transport::PipeTransportDump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TransportDumpData::PlainTransportDump: {
      auto ptr = reinterpret_cast<const FBS::Transport::PlainTransportDump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TransportDumpData::WebRtcTransportDump: {
      auto ptr = reinterpret_cast<const FBS::Transport::WebRtcTransportDump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTransportDumpDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<TransportDumpData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTransportDumpData(
        verifier,  values->Get(i), types->GetEnum<TransportDumpData>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *TransportProtocolTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TransportProtocolTypeTable
  };
  static const int64_t values[] = { 1, 2 };
  static const char * const names[] = {
    "UDP",
    "TCP"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransportDumpDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::BaseTransportDumpTypeTable,
    FBS::Transport::DirectTransportDumpTypeTable,
    FBS::Transport::PipeTransportDumpTypeTable,
    FBS::Transport::PlainTransportDumpTypeTable,
    FBS::Transport::WebRtcTransportDumpTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "BaseTransportDump",
    "DirectTransportDump",
    "PipeTransportDump",
    "PlainTransportDump",
    "WebRtcTransportDump"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TransportListenIpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ip",
    "announcedIp"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConsumeRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_UCHAR, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable,
    FBS::RtpParameters::RtpParametersTypeTable,
    FBS::RtpParameters::TypeTypeTable,
    FBS::RtpParameters::RtpEncodingParametersTypeTable,
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "consumerId",
    "producerId",
    "kind",
    "rtpParameters",
    "type",
    "consumableRtpEncodings",
    "paused",
    "preferredLayers",
    "ignoreDtx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConsumeResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Consumer::ConsumerScoreTypeTable,
    FBS::Consumer::ConsumerLayersTypeTable
  };
  static const char * const names[] = {
    "paused",
    "producerPaused",
    "score",
    "preferredLayers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProduceRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::MediaKindTypeTable,
    FBS::RtpParameters::RtpParametersTypeTable,
    FBS::RtpParameters::RtpMappingTypeTable
  };
  static const char * const names[] = {
    "producerId",
    "kind",
    "rtpParameters",
    "rtpMapping",
    "keyFrameRequestDelay",
    "paused"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProduceResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::RtpParameters::TypeTypeTable
  };
  static const char * const names[] = {
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProduceDataRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::SctpStreamParametersTypeTable
  };
  static const char * const names[] = {
    "dataProducerId",
    "type",
    "sctpStreamParameters",
    "label",
    "protocol"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConsumeDataRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::SctpStreamParametersTypeTable
  };
  static const char * const names[] = {
    "dataConsumerId",
    "dataProducerId",
    "type",
    "sctpStreamParameters",
    "label",
    "protocol"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RtpListenerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint32StringTypeTable,
    FBS::Common::StringStringTypeTable
  };
  static const char * const names[] = {
    "ssrcTable",
    "midTable",
    "ridTable"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SctpListenerTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint16StringTypeTable
  };
  static const char * const names[] = {
    "streamIdTable"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DumpResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::TransportDumpDataTypeTable
  };
  static const char * const names[] = {
    "data_type",
    "data"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BaseTransportDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Common::Uint32StringTypeTable,
    FBS::Common::StringUint8TypeTable,
    FBS::Transport::RtpListenerTypeTable,
    FBS::SctpParameters::SctpParametersTypeTable,
    FBS::Transport::SctpListenerTypeTable
  };
  static const char * const names[] = {
    "id",
    "direct",
    "producerIds",
    "consumerIds",
    "mapSsrcConsumerId",
    "mapRtxSsrcConsumerId",
    "dataProducerIds",
    "dataConsumerIds",
    "recvRtpHeaderExtensions",
    "rtpListener",
    "maxMessageSize",
    "sctpParameters",
    "sctpState",
    "sctpListener",
    "traceEventTypes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IceParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "usernameFragment",
    "password",
    "iceLite"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IceCandidateTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "foundation",
    "priority",
    "ip",
    "protocol",
    "port",
    "type",
    "tcpType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TupleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "localIp",
    "localPort",
    "remoteIp",
    "remotePort",
    "protocol"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FingerprintTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "algorithm",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DtlsParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::FingerprintTypeTable
  };
  static const char * const names[] = {
    "fingerprints",
    "role"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WebRtcTransportDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::DumpResponseTypeTable,
    FBS::Transport::IceParametersTypeTable,
    FBS::Transport::IceCandidateTypeTable,
    FBS::Transport::TupleTypeTable,
    FBS::Transport::DtlsParametersTypeTable
  };
  static const char * const names[] = {
    "base",
    "iceRole",
    "iceParameters",
    "iceCandidates",
    "iceState",
    "iceSelectedTuple",
    "dtlsParameters",
    "dtlsState"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SrtpParametersTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "cryptoSuite",
    "keyBase64"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PlainTransportDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::DumpResponseTypeTable,
    FBS::Transport::TupleTypeTable,
    FBS::Transport::SrtpParametersTypeTable
  };
  static const char * const names[] = {
    "base",
    "rtcMux",
    "comedia",
    "tuple",
    "rtcpTuple",
    "srtpParameters"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DirectTransportDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::DumpResponseTypeTable
  };
  static const char * const names[] = {
    "base"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PipeTransportDumpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::Transport::DumpResponseTypeTable,
    FBS::Transport::TupleTypeTable,
    FBS::Transport::SrtpParametersTypeTable
  };
  static const char * const names[] = {
    "base",
    "tuple",
    "rtx",
    "srtpParameters"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BaseTransportOptionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FBS::SctpParameters::NumSctpStreamsTypeTable
  };
  static const char * const names[] = {
    "direct",
    "maxMessageSize",
    "initialAvailableOutgoingBitrate",
    "enableSctp",
    "numSctpStreams",
    "maxSctpMessageSize",
    "sctpSendBufferSize",
    "isDataChannel"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SetMaxIncomingBitrateRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "maxIncomingBitrate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SetMaxOutgoingBitrateRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "maxOutgoingBitrate"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EnableTraceEventRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "events"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CloseProducerRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "producerId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CloseConsumerRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "consumerId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CloseDataProducerRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dataProducerId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CloseDataConsumerRequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "dataConsumerId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace Transport
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_TRANSPORT_FBS_TRANSPORT_H_
