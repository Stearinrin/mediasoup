// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { Uint16String, Uint16StringT } from '../../fbs/common/uint16string';


export class SctpListener {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):SctpListener {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSctpListener(bb:flatbuffers.ByteBuffer, obj?:SctpListener):SctpListener {
  return (obj || new SctpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSctpListener(bb:flatbuffers.ByteBuffer, obj?:SctpListener):SctpListener {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new SctpListener()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

streamIdTable(index: number, obj?:Uint16String):Uint16String|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Uint16String()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

streamIdTableLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startSctpListener(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addStreamIdTable(builder:flatbuffers.Builder, streamIdTableOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, streamIdTableOffset, 0);
}

static createStreamIdTableVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startStreamIdTableVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endSctpListener(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  builder.requiredField(offset, 4) // stream_id_table
  return offset;
}

static createSctpListener(builder:flatbuffers.Builder, streamIdTableOffset:flatbuffers.Offset):flatbuffers.Offset {
  SctpListener.startSctpListener(builder);
  SctpListener.addStreamIdTable(builder, streamIdTableOffset);
  return SctpListener.endSctpListener(builder);
}

unpack(): SctpListenerT {
  return new SctpListenerT(
    this.bb!.createObjList(this.streamIdTable.bind(this), this.streamIdTableLength())
  );
}


unpackTo(_o: SctpListenerT): void {
  _o.streamIdTable = this.bb!.createObjList(this.streamIdTable.bind(this), this.streamIdTableLength());
}
}

export class SctpListenerT {
constructor(
  public streamIdTable: (Uint16StringT)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const streamIdTable = SctpListener.createStreamIdTableVector(builder, builder.createObjectOffsetList(this.streamIdTable));

  return SctpListener.createSctpListener(builder,
    streamIdTable
  );
}
}
